%!TEX root = fastZKP.tex

\subsection{GKR Protocol}\label{subsec::GKR}


Using the sumcheck protocol as a building block, Goldwasser et al.~\cite{GKR} showed an interactive proof protocol (referred as the \emph{GKR protocol} in this paper) for \textit{layered arithmetic circuits}. 

\smallskip\noindent\textbf{High Level Ideas.} Let $C$ be a layered arithmetic circuit with depth $d$ over a finite field $\mathbb{F}$. Each gate in the $i$-th layer takes inputs from two gates in the $(i+1)$-th layer; layer $0$ is the output layer and layer $d$ is the input layer. The protocol proceeds layer by layer. Upon receiving the claimed output from the prover, in the first round, the verifier and the prover run the sumcheck protocol to reduce the claim about the output to a claim about the values of the wire in the layer above. In the $i$-th round, both parties reduces a claim about layer $i-1$ to a claim about layer $i$ through the sumcheck protocol. Finally, the protocol terminates with a claim about the input layer $d$, which can be checked directly by the verifier, or given as an oracle access. If the check passes, the verifier accepts the claimed output. 

\subsubsection{Notations}

Before describing the GKR protocol, we introduce some additional notations. We denote the number of gates in the $i$-th layer as $S_i$ and let $s_i = \ceil{\log S_i}$. (For simplicity, we assume $S_i$ is a power of 2, and we can pad the layer with dummy gates otherwise.) We then define a function $V_i:\binary^{s_i}\rightarrow\mathbb{F}$ that takes a binary string $b\in\binary^{s_i}$ and returns the output of gate $b$ in layer $i$, where $b$ is called the gate label. With this definition, $V_0$ corresponds to the output of the circuit, and $V_d$ corresponds to the input layer. Finally, we define two additional functions $add_i, mult_i: \binary^{s_{i-1}+2s_i}\rightarrow\binary$, referred as \emph{wiring predicates} in the literature. $add_i$ ($mult_i$) takes one gate label $z\in\binary^{s_{i-1}}$ in layer $i-1$ and two gate labels $x,y\in\binary^{s_i}$ in layer $i$, and outputs 1 if and only if gate $z$ is an addition (multiplication) gate that takes the output of gate $x,y$ as input. With these definitions, $V_i$ can be written as follows:
\begin{equation}
	V_i(z)=\sum_{x, y \in\binary^{s_{i+1}}}(add_{i+1}(z,x,y)(V_{i+1}(x)+V_{i+1}(y))+mult_{i+1}(z,x,y)(V_{i+1}(x)V_{i+1}(y)))
\end{equation}
for any $z\in\binary^{s_i}$. 









\ignore{
\yupeng{try to remove $\beta$.}

\begin{definition}[Multilinear extension of identity fucntion]
Here we present a multilinear extension of identity function
\begin{eqnarray}\beta_{l}(a, b)=
	\begin{cases}
	1, &a=b\cr 0, &a\neq b
	\end{cases}
\end{eqnarray}
Where $a, b$ are binary strings with length $l$. The multilinear extension is the following:

$$\tilde{\beta_{l}}(a,b)\overset{def}{=}\prod_{j=1}^{l}((1-a_{j})(1-b_{j})+a_{j}b_{j})$$

We have $\tilde{\beta_{l}}(a,b)=\beta_{l}(a, b)$ when $a, b$ are binary.
\end{definition}

\begin{definition}[Multilinear extension of $add$, $mult$]
We will define the multilinear extension of two component of $V_i$.
$$\tilde{add}_{i}(g, u, v)=\sum_{(g', u', v') \in G_{i, add}}\tilde{\beta}_{s_i}(g, g')\tilde{\beta}_{s_{i+1}}(u, u')\tilde{\beta}_{s_{i+1}}(v, v')$$

$$\tilde{mult}_{i}(g, u, v)=\sum_{(g', u', v') \in G_{i, mult}}\tilde{\beta}_{s_i}(g, g')\tilde{\beta}_{s_{i+1}}(u, u')\tilde{\beta}_{s_{i+1}}(v, v')$$
\end{definition}

\begin{definition}[Multilinear extension of $V_i(g)$]
	\label{def::multilinear}
	%$$\tilde{V}_{i}(z)=\sum_{g\in\{0,1\}^{s_i} u, v\in \{0,1\}^{s_{i+1}}}f_{i,z}(g,u,v)$$

	%$$f_{i,z}(g,u,v)\overset{def}{=}\tilde{\beta_{i}}(z, g)[\tilde{mult}(g, u, v)(\tilde{V}_{i+1}(u)\tilde{V}_{i+1}(v))+\tilde{add}(g,u,v)(\tilde{V}_{i+1}(u)+\tilde{V}_{i+1}(v))]$$
	%where $$\tilde{\beta_{i}}(z,g)\overset{def}{=}\prod_{j=1}^{s_{i}}((1-g_{j})(1-z_{j})+g_{j}z_{j})$$

	%$$\tilde{mult}(g,u,v)\overset{def}{=}\sum_{(g', u', v')\in G_{i,mult}}\tilde{\beta_{i}}(g,g')\tilde{\beta_{i+1}}(u,u')\tilde{\beta_{i+1}}(v,v')$$

	%$$\tilde{add}(g,u,v)\overset{def}{=}\sum_{(g', u', v')\in G_{i,add}}\tilde{\beta_{i}}(g,g')\tilde{\beta_{i+1}}(u,u')\tilde{\beta_{i+1}}(v,v')$$

	%when $a, b$ are binary strings, $\tilde{\beta_{i}}(a, b)$ will output $1$ when $a=b$, and $0$ otherwise. $\tilde{mult},\tilde{add}$ is the multilinear extension of the wiring predicates. A wiring predicates is a function of three gates $g_1, g_2, g_3$, and returns $1$ if $g_1$ takes $g_2, g_3$ as it's input.

	We define the multilinear extension of $V_i(g)$ in the following way:

	$$\tilde{V}_i(g)=\sum_{u, v \in \{0,1\}^{s_{i+1}}}(\tilde{add}_{i+1}(g, u, v)(\tilde{V}_{i+1}(u)+\tilde{V}_{i+1}(v))+\tilde{mult}_{i+1}(g,u,v)(\tilde{V}_{i+1}(u)\tilde{V}_{i+1}(v)))\textnormal{,}$$
	where $\tilde{mult}$ and $\tilde{add}$ are multilinear extension of $mult$ and $add$.
\end{definition}

}



\subsubsection{Protocol Details}\label{sec::gkr}

In the equation above, $V_i$ is expressed as a summation, so the verifier $\V$ can use the sumcheck protocol to check that it is computed correctly. As the sumcheck protocol operates on polynomials defined on $\mathbb{F}$, we rewrite the equation with their multilinear extensions:
\begin{align}\label{eq:GKR}
\tV_i(g)&=\sum_{x, y \in\binary^{s_{i+1}}}f_i(x,y)\nonumber\\
&=\sum_{x, y \in\binary^{s_{i+1}}}(\tadd_{i+1}(g,x,y)(\tV_{i+1}(x)+\tV_{i+1}(y))+\tmult_{i+1}(g,x,y)(\tV_{i+1}(x)\tV_{i+1}(y)))
\end{align}
where $g\in\mathbb{F}^{s_i}$ is a random vector. 

With Equation~\ref{eq:GKR}, the GKR protocol proceeds as following. The prover $\P$ first sends the claimed output of the circuit to the verifier $\V$. From the claimed output, $\V$ defines polynomial $\tV_0$ and computes $\tV_0(g)$ for a random $g\in\mathbb{F}^{s_0}$. $\V$ and $\P$ then invoke a sumcheck protocol on Equation~\ref{eq:GKR} with $i=0$. As described in Section~\ref{subsec::sumcheck}, at the end of the sumcheck, $\V$ needs an oracle access to $f_i(u,v)$, where $u,v$ are randomly selected in $\mathbb{F}^{s_{i+1}}$. To compute $f_i(u,v)$, $\V$ computes $\tadd_{i+1}(u,v)$ and $\tmult_{i+1}(u,v)$ locally (they only depend on the wiring pattern of the circuit, but not on the values), asks $\P$ to send $\tV_1(u)$ and $\tV_1(v)$ and computes $f_i(u,v)$ to complete the sumcheck protocol. In this way, $\V$ and $\P$ reduces a claim about the output to two claims about values in layer 1. $\V$ and $\P$ could invoke two sumcheck protocols on $\tV_1(u)$ and $\tV_1(v)$ to reduce them to claims on layer 2, and continue recursively until the input layer. However, by doing so, the number of claims and the sumcheck protocols increases exponentially to $d$ , and the verification time is even more expensive than computing locally. 

\smallskip\noindent\textbf{Combining two claims: condensing to one claim.} In~\cite{GKR}, Goldwasser et al. presented a protocol to reduce two claims $\tV_i(u)$ and $\tV_i(v)$ to one as following. $\V$ defines a line $\gamma: \mathbb{F} \rightarrow \mathbb{F}^{s_i}$ such that $\gamma(0)=u, \gamma(1)=v$. $\V$ sends $\gamma(x)$ to $\P$. Then $\P$ sends $\V$ a degree $s_i$ univariate polynomial $h(x)=\tilde{V_i}(\gamma(x))$. $\V$ checks that $h(0)=\tV_i(u), h(1)=\tV_i(v)$. Then $\V$ randomly chooses $r\in\mathbb{F}$ and computes a new claim $h(r) = \tV_i(\gamma(r)) = \tV_i(w)$ on $w=\gamma(r) \in \mathbb{F}^{s_i}$. $\V$ sends $r, w$ to $\P$. In this way, the two claims are reduced to one claim $\tV_i(w)$. Combining this protocol with the sumcheck protocol on Equation~\ref{eq:GKR}, $\V$ and $\P$ can reduce a claim on layer $i$ to one claim on layer $i+1$, and eventually to a claim on the input, which completes the GKR protocol.

\smallskip\noindent\textbf{Combining two claims: random linear combination.}  In~\cite{zksumcheck}, Chiesa et al. proposed an alternative approach using random linear combinations. Upon receiving the two claims $\tV_i(u)$ and $\tV_i(v)$, $\V$ selects $\alpha_i, \beta_i\in\mathbb{F}$ randomly and computes $\alpha_i\tV_i(u)+\beta_i\tV_i(v)$. Based on Equation~\ref{eq:GKR}, this random linear combination can be written as
\begin{align}\label{eq:randomGKR}
&\alpha_i\tV_i(u)+\beta_i\tV_i(v)\nonumber\\
=&\alpha_i\sum_{x, y \in\binary^{s_{i+1}}}(\tadd_{i+1}(u,x,y)(\tV_{i+1}(x)+\tV_{i+1}(y))+\tmult_{i+1}(u,x,y)(\tV_{i+1}(x)\tV_{i+1}(y)))\nonumber\\
&+\beta_i\sum_{x, y \in\binary^{s_{i+1}}}(\tadd_{i+1}(v,x,y)(\tV_{i+1}(x)+\tV_{i+1}(y))+\tmult_{i+1}(v,x,y)(\tV_{i+1}(x)\tV_{i+1}(y)))\nonumber\\
=&\sum_{x, y \in\binary^{s_{i+1}}}((\alpha_i\tadd_{i+1}(u,x,y)+\beta_i\tadd_{i+1}(v,x,y))(\tV_{i+1}(x)+\tV_{i+1}(y))\nonumber\\
&+(\alpha_i\tmult_{i+1}(u,x,y)+\beta_i\tmult_{i+1}(v,x,y))(\tV_{i+1}(x)\tV_{i+1}(y)))
\end{align}
$\V$ and $\P$ then execute the sumcheck protocol on Equation~\ref{eq:randomGKR} instead of Equation~\ref{eq:GKR}. At the end of the sumcheck protocol, $\V$ still receives two claims about $\tV_{i+1}$, computes their random linear combination and proceeds to an layer above recursively until the input layer.

In our new ZKP scheme, we will mainly use the second approach. The full GKR protocol using random linear combinations is given in Figure~\ref{protocol::CMT}. \yupeng{change the protocol using the 2nd approach and new notations, and put it into a figure.}

\begin{protocol}
	\label{protocol::CMT}
	Let $\mathbb{F}$ be a prime field. Let $C$: $\mathbb{F}^n\rightarrow \mathbb{F}^k$ be a $d$-depth layered arithmetic circuit. $\mathcal{P}$ is the prover and $\mathcal{V}$ is the prover. $\mathcal{P}$ wants to convince that $y=C(x)$ where $x$ is the input from the verifier $\mathcal{V}$, and $y$ is the output array, the detailed protocol:

	\begin{itemize}
		\item Suppose without loss of generality, $|y|=2^k$, we can pad element if the actual length of $y$ is not a power of $2$.
		\item By the definition of $V_i(j)$, $V_0(j)$ is $y_j$, $j$-th element of the output array. The verifier chooses uniform $r_0 \in \mathbb{F}^k$. Both parties set $a_0=\tilde{V_0}(r_0)$
		\item For $i=1,...,d$:
		\begin{itemize}
			\item Both parties runs sumcheck protocol for $a_{i-1}$ on polynomial $\tilde{V_{i-1}}$, in the last step of sumcheck, verifier need to access the oracle to compute $$\tilde{add}_{i-1}(g, R_{u}, R_{v})(\tilde{V}_{i}(R_{u})+\tilde{V}_{i}(R_v))+\tilde{mult}_{i-1}(g, R_{u}, R_{v})(\tilde{V}_{i}(R_{u})\tilde{V}_{i}(R_v))\textnormal{,}$$ 
			where $R_{u}, R_{v}$ are chosen randomlly from $\mathbb{F}^{|u|},\mathbb{F}^{|v|}$. 

			\item Here we implement the oracle: the verifier asks the value of $\tilde{V}_i(u), \tilde{V}_i(v)$ from the prover, and the verifier compute $\tilde{add}, \tilde{mult}$ locally. 
			\item Then the verifier combines $\tilde{V_{i}}(R_{u}), \tilde{V_{i}}(R_{v})$ in this way: 
			\begin{itemize}
				\item Let $\gamma: \mathbb{F} \rightarrow \mathbb{F}^{s_i}$ be a line with $\gamma(0)=R_{u}, \gamma(1)=R_{v}$. 
				\item The verifier sends $\gamma(x)$ to the prover. 
				\item Then prover send a degree $s_i$ polynomial $h(x)=\tilde{V_{i}}(\gamma(x))$. The verifier verifies that $h(0)=v_0, h(1)=v_1$. And it compute $a_i=h(r_i)$ by randomly choose $r_i'$ and set $r_i=\gamma(r_i')$ and sends $r_i, a_i$ to prover.
			\end{itemize}
		\end{itemize}
		\item The verifier accepts iff $a_d = \tilde{V_d}(r_d)$, where $\tilde{V_d}$ is the multi-linear extension representation of input layer.
	\end{itemize}
\end{protocol}

\begin{theorem}\cite{VSA13}\cite{JT_Thesis}\cite{CMT}\cite{GKR}. Let $C$ : $\mathbb{F}^n \rightarrow \mathbb{F}^k$ be a depth-$d$ layered arithmetic circuit. Protocol \ref{protocol::CMT} is an interactive proof for the function computed by $C$ with soundness $O(\frac{d\log {S}}{|\mathbb{F}|})$, where $S$ is the maximal number of gates per circuit layer. It uses $O(d \log S)$ rounds of interaction and running time of prover $\mathcal{P}$ is $O(|C|\log S)$. Let the optimal computation time for $\tilde{add_i}$ and $\tilde{mult_i}$ be $T$, the running time of the verifier is $O(n+k+dT)$, in some applications, $T=\poly{\log S}$. \yupeng{rephrase the theorem.}
\end{theorem}