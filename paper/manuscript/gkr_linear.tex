%!TEX root = fastZKP.tex
\section{Linear Prover Time GKR Protocol}
\label{sec::gkrlin}
In this section we will improve the GKR protocol\cite{GKR} to make the prover runs in linear time. Our work is based on the CMT protocol \cite{CMT}.

\subsection{Roadmap}
Through out the whole CMT protocol, the prover has to answer two type of queries:
\begin{enumerate}
	\item the query related to sumcheck.
	\item the query to combine the points. 
\end{enumerate}

We will deal with these queries seperately. The equation in sumcheck queries are well structured. For each sumcheck we are going to check the claim $a_i=\tilde{V_i}(r_i)$. Since the sumcheck deal with the parameters one by one, we can divide the sumcheck into two stages as follows: the first stage is the sumcheck about variables in $u$ and the second stage is the sumcheck about the variaibles in $v$. Also notice that $\tilde{mult}$ and $\tilde{add}$ are independent in the equation, where independent means that we can calculate them seperately and the final answer is the sum of these two. So we can treat them seperately using two similar algorithm. For simplicity, in this subsection we only discuss the idea of calculate $\tilde{mult}$ part. 

For a generic sumcheck protocol, if we can initialize all binary values to an array, we can answer the first sumcheck query by scanning through the array, and reduce the array into a new array with only half size of the previous array since the summation size in the sumcheck is halved. By reducing the array, we can answer all queries in linear time to the initial array size.

Unfortunatelly, we cannot directly use this technique to our protocol since if we directly initialize the array, the time complexity would be the square of the current layer size since we have two variables. But noticed that these two variables are well seperated, we can calculate them seperately. In the first part of sumcheck, the verifier will only asks questions about $u$, in this part we can preprocess the calculation of $v$, since we are doing the exact the same summation on $v$, we do not need to recalculate it every round. In the second part, we can use the generic sumcheck protocol since we only have one variable left, and we will show an algorithm to initialize arrays in the generic sumcheck protocol.

For the combination part, it's quite straightforward, we defer the introduction to the detailed protocol.

\subsubsection{Linear Prover Time Sumcheck}
We will follow the CMT protocol, and improve the performance of sumcheck and the performance of combining two points. We will break the protocol into two parts, the first part deal with queries about $u$, and the second part will deal with queries about $v$.
\subsubsection{Part One} In this part, we will deal with queries in first $s_{i+1}$ rounds.
\paragraph{Review the sumcheck}
In this subsection, we focus on answering the sumcheck queries. In the first round, the verifier asks the prover to give a univariate function: 

$$f_{i, 1}(x_1)=\sum_{u_{k} \in \{0, 1\}, v \in \{0, 1\}^{s_{i+1}}}\tilde{mult}_{i}(g, \{x_1, u_{2},..., u_{s_{i+1}}\}, v)(\tilde{V}_{i+1}(x_1, u_{2},..., u_{|u|})\tilde{V}_{i+1}(v)),$$
where $v$ is a binary vector in $\{0, 1\}^{s_{i+1}}$, $\{x_1, u_{2},..., u_{s_{i+1}}\}$ is the representation of $u$.

In the $k$-th round where $2\le k\le s_{i+1}$, the verifier asks the prover to give a univariate function:
\begin{align*}
f_{i,k}(x_k)=\sum_{u_k \in \{0, 1\}, v \in \{0, 1\}^{s_{i+1}}}\tilde{mult}_{i}(g, \{r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}}\}, v)\times\\
(\tilde{V}_{i+1}(r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}})\tilde{V}_{i+1}(v))
\end{align*}
where $v$ is a binary vector in $\{0, 1\}^{s_{i+1}}$, $\{r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}}\}$ is the representation of $u$.

\paragraph{The Definition of Building Block}
In the first round, we calculate two arraies to help speed up calculation, where each array element is a pair $(a, b)$ representing a linear function $ax+b$.

The first array is $\overline{mult}_1$, where $\overline{mult}_1[p]$ is a pair $(a, b)$ representing a linear function as follows:
$$\overline{mult}_1[p]\overset{def}{=}\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_i(g, \{x_1, p\}, v)\tilde{V}_{i+1}(v),$$
here $p$ is a $s_{i+1}-1$ bits binary number. $\{x_1, p\}$ is the representation of $u$. Similarly we define our second array $\overline{V}_1[p]$ as follows:
$$\overline{V}_1[p]\overset{def}{=}\tilde{V}_i(\{x_1, p\})$$

We will treat both arrays as a linear function or a pair of field elements interchangeably, for example $\overline{mult}_1[p](x)$ means we treat it as a linear function, and $\overline{mult}_1[p].a, \overline{mult}_1[p].b$ means we treat it as a pair.

Similarly we define arrays that used in $k$-th round as follows:
\begin{definition}[Linear Function Array]

	The definition for $k=1$ is the statement above, for $k\ge 2$
	\begin{enumerate}
		\item $\overline{mult}_k[p]\overset{def}{=}\sum_{v\in \{0, 1\}^{s_{i+1}}}\tilde{mult}_i(g, \{r_1, ..., r_{k-1}, x_k, p\}, v)\tilde{V}_{i+1}(v)$
		\item $\overline{V}_k[p]\overset{def}{=}\tilde{V}_i(\{r_1, ..., r_{k-1}, x_k, p\})$
		\item Where $p$ is a $s_{i+1}-k$ bits binary number and $\{r_1, ..., r_{k-1}, x_k, p\}$ is the representation of $u$.
	\end{enumerate}
\end{definition}

\paragraph{Initialize Arrays}
We will try to initialize $\overline{mult}_1, \overline{V}_1$. And we will calculate next arrays using these arrays.

For $\overline{V}_1$, we can scan through the circuit and get all values of $\tilde{V}_{i+1}(u)$ when $u \in \{0, 1\}^{s_{i+1}}$, and we have the following equations:
\begin{align*}
\overline{V}_1[p](0)=\tilde{V}_{i+1}(0||p)\\
\overline{V}_1[p](1)=\tilde{V}_{i+1}(1||p)
\end{align*}
We can solve for $\overline{V}_1[p]$ easily.

For $\overline{mult}_1$, the idea is the same as $\overline{V}_1$, but it's non-trivil to calculate $\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_{i+1}(g, u, v)\tilde{V}_{i+1}(v)$ for every binary $u$ in linear time, since we need to calculate $\tilde{\beta}_{s_{i}}(g, g')$ part in $\tilde{mult}_{i+1}(g, u, v)$. Instead enumerate every binary $u$ to initialize the array, we can enumberate $g'$ instead. And accumulate the contribution of $(g', u', v')$ to $\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_{i+1}(g, u', v)\tilde{V}_{i+1}(v)$. We will use a depth first search to enumerate every $g'$ bit by bit. The detailed algorithm is shown in Algorithm \ref{alg::premult}.
\begin{figure}[p]
\begin{algorithm}[H]
\label{alg::premult}
\caption{Preprocess $\overline{mult}_1$}
\begin{algorithmic}[1]
\parState{Assuming we have global access to $g$, $s_i$, $s_{i+1}$, which is resonable since prover knows these values, and $g[k]$ means the $k$-th field element of $g$, starting from $0$ since we are writing pseudo-code}
\Procedure{{\sf DFS}}{$A$, $g'$, $depth$, $Value$}
	\parState{Note $A$, $g'$ is the pointer to the array, any change to $A$ or $g'$ will change it globally.}
	\parState{In this function, we will recurse on the bits of $g$}
	\If {$depth=s_{i}$} \Comment{We have enumerate enough bits}
		\State Let $u', v'$ is input gates to $g'$
		\State Find $\tilde{V}_{i+1}(v')$ in circuit.
		\State $A[u'] = A[u'] + \tilde{V}_{i+1}(v')\times Value$
	\Else
		\State set $g'[depth]=0$
		\State Call {\sf DFS}($A$, $g'$, $depth+1$, $Value\times(1-g[depth])$)
		\State set $g'[depth]=1$
		\State Call {\sf DFS}($A$, $g'$, $depth+1$, $Value\times g[depth]$)
	\EndIf
\EndProcedure
\Procedure{{\sf InitializeMult}}{}
	\State Let array $\overline{mult}_1$ be filled with zeros.
	\parState{Since calculate $\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_{i+1}(g, u, v)\tilde{V}_{i+1}(v)$ for every binary $u$ is enough to initialize array $\overline{mult}_1$, we will call a subroutine to initialize every binary $u$, and store the result into array $A$.}
	\State Initialize array $A$ with zeros.
	\State let $g'$ be a vector of $s_{i+1}$ bits.
	\State Call {\sf DFS}($A$, $g'$, $0$, $1$)
	\For{each $p \in \{0, 1\}^{s_{i+1}-1}$}
		\parState{By solving the linear equations, we can get the following statements}
		\State $\overline{mult}_1[p].b=A[0||p]$
		\State $\overline{mult}_1[p].a=A[1||p]-A[0||p]$
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{figure}

\paragraph{Answer Queries}
The answer to the first query is the following univariate function:

$$\sum_{p}\overline{mult}_1[p](x)\times\overline{V}_1[p](x),$$

It's easy to get this result by doing some transformation on the original equation.

We reduce these arraies to the second round using the following way

\begin{enumerate}
	\item By definition, $\overline{mult}_2[p'](0)=\overline{mult}_1[0||p'](r_1)$ and $\overline{mult}_2[p'](1)=\overline{mult}_1[1||p'](r_1)$
	\item By definition, $\overline{V}_2[p'](0)=\overline{V}_1[0||p'](r_1)$ and $\overline{V}_2[p'](1)=\overline{V}_1[1||p'](r_1)$

	\item Since both $\overline{mult}, \overline{V}$ are linear equations, we can solve the $\overline{mult}_2, \overline{V}_2$ by solving linear equations.
	\item By solving linear equations we found that $\overline{mult}_2[p'].b=\overline{mult}_1[0||p'](r_1)$ and $\overline{mult}_2[p'].a=\overline{mult}_1[1||p'](r_1)-\overline{mult}_1[0||p'](r_1)$
\end{enumerate}

The answer to the second round is 

$$\sum_{p'}\overline{mult}_2[p']\times\overline{V}_2[p']$$

We define arrays for the $k$-th round ($k\ge 2$) in the similarly using the result from $k-1$-th round, and solving the linear equation.

The answer to the $k$-th round query is 
$$\sum_{p}\overline{mult}_k[p]\times\overline{V}_k[p]$$

\begin{theorem} For every round, the algorithm above correctly answered the query. And the running time of the algorithm runs in time $O(\max(2^{s_i}, 2^{s_{i+1}}))$.
\end{theorem}

\begin{proof}
It's trivial to see that $\overline{mult}_k, \overline{V}_k$ are computed correctly. 

For time complexity part, $\overline{mult}_k, \overline{V}_k$ are computed in linear time since Algorithm \ref{alg::premult} runs in linear time, and for $k$-th layer, the size of $\overline{mult}_k$ is half size of $\overline{mult}_{k-1}$, by total size of these arraies is linear to the circuit size.

The answer to the verifier is correct by the definition of $\overline{mult}_k, \overline{V}_k$.
\end{proof}

\subsubsection{Part two}

\subsubsection{Combining two points}