%!TEX root = fastZKP.tex
\section{Linear Prover Time GKR Protocol}
\label{sec::gkrlin}
In this section we will improve the GKR protocol\cite{GKR} to make the prover runs in linear time. Our work is based on the CMT protocol \cite{CMT}.

\subsection{Roadmap}
Through out the whole CMT protocol, the prover has to answer two type of queries:
\begin{enumerate}
	\item the query related to sumcheck.
	\item the query to combine the points. 
\end{enumerate}

We will deal with these queries seperately. The equation in sumcheck queries are well structured. For each sumcheck we are going to check the claim $a_i=\tilde{V_i}(r_i)$. Since the sumcheck deal with the parameters one by one, we can divide the sumcheck into two stages as follows: the first stage is the sumcheck about variables in $u$ and the second stage is the sumcheck about the variaibles in $v$. Also notice that $\tilde{mult}$ and $\tilde{add}$ are independent in the equation, where independent means that we can calculate them seperately and the final answer is the sum of these two. So we can treat them seperately using two similar algorithm. For simplicity, in this subsection we only discuss the idea of calculate $\tilde{mult}$ part. 

For a generic sumcheck protocol, if we can initialize all binary values to an array, we can answer the first sumcheck query by scanning through the array, and reduce the array into a new array with only half size of the previous array since the summation size in the sumcheck is halved. By reducing the array, we can answer all queries in linear time to the initial array size.

Unfortunatelly, we cannot directly use this technique to our protocol since if we directly initialize the array, the time complexity would be the square of the current layer size since we have two variables. But noticed that these two variables are well seperated, we can calculate them seperately. In the first part of sumcheck, the verifier will only asks questions about $u$, in this part we can preprocess the calculation of $v$, since we are doing the exact the same summation on $v$, we do not need to recalculate it every round. In the second part, we can use the generic sumcheck protocol since we only have one variable left, and we will show an algorithm to initialize arrays in the generic sumcheck protocol.

For the combination part, it's quite straightforward, we defer the introduction to the detailed protocol.

\subsubsection{Linear Prover Time Sumcheck}
We will follow the CMT protocol, and improve the performance of sumcheck and the performance of combining two points. We will break the protocol into two parts, the first part deal with queries about $u$, and the second part will deal with queries about $v$.
\subsubsection{Part One} In this part, we will deal with queries in first $s_{i+1}$ rounds.
\paragraph{Review the sumcheck}
In this subsection, we focus on answering the sumcheck queries. In the first round, the verifier asks the prover to give a univariate function: 

$$f_{i, 1}(x_1)=\sum_{u_{k} \in \{0, 1\}, v \in \{0, 1\}^{s_{i+1}}}\tilde{mult}_{i}(g, \{x_1, u_{2},..., u_{s_{i+1}}\}, v)(\tilde{V}_{i+1}(x_1, u_{2},..., u_{|u|})\tilde{V}_{i+1}(v)),$$
where $v$ is a binary vector in $\{0, 1\}^{s_{i+1}}$, $\{x_1, u_{2},..., u_{s_{i+1}}\}$ is the representation of $u$.

In the $k$-th round where $2\le k\le s_{i+1}$, the verifier asks the prover to give a univariate function:
\begin{align*}
f_{i,k}(x_k)=\sum_{u_k \in \{0, 1\}, v \in \{0, 1\}^{s_{i+1}}}\tilde{mult}_{i}(g, \{r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}}\}, v)\times\\
(\tilde{V}_{i+1}(r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}})\tilde{V}_{i+1}(v))
\end{align*}
where $v$ is a binary vector in $\{0, 1\}^{s_{i+1}}$, $\{r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}}\}$ is the representation of $u$.

\paragraph{The Definition of Building Block}
In the first round, we calculate two arraies to help speed up calculation, where each array element is a pair $(a, b)$ representing a linear function $ax+b$.

The first array is $mult_1^1$, where $mult_1^1[p]$ is a pair $(a, b)$ representing a linear function as follows:
$${mult}_1^1[p]\overset{def}{=}\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_i(g, \{x_1, p\}, v)\tilde{V}_{i+1}(v),$$
here $p$ is a $s_{i+1}-1$ bits binary number. $\{x_1, p\}$ is the representation of $u$. Similarly we define our second array ${V}_1^1[p]$ as follows:
$$V_1^1[p]\overset{def}{=}\tilde{V}_i(\{x_1, p\})$$

We will treat both arrays as a linear function or a pair of field elements interchangeably, for example ${mult}_1^1[p](x)$ means we treat it as a linear function, and ${mult}_1^1[p].a, {mult}_1^1[p].b$ means we treat it as a pair.

Similarly we define arrays that used in $k$-th round as follows:
\begin{definition}[Linear Function Array Part One]

	The definition for $k=1$ is the statement above, for $k\ge 2$
	\begin{enumerate}
		\item ${mult}_k^1[p]\overset{def}{=}\sum_{v\in \{0, 1\}^{s_{i+1}}}\tilde{mult}_i(g, \{r_1, ..., r_{k-1}, x_k, p\}, v)\tilde{V}_{i+1}(v)$
		\item ${V}_k^1[p]\overset{def}{=}\tilde{V}_i(\{r_1, ..., r_{k-1}, x_k, p\})$
		\item Where $p$ is a $s_{i+1}-k$ bits binary number and $\{r_1, ..., r_{k-1}, x_k, p\}$ is the representation of $u$.
	\end{enumerate}
\end{definition}

\paragraph{Initialize Arrays}
We will try to initialize ${mult}_1^1, {V}_1^1$. And we will calculate next arrays using these arrays.

For ${V}_1^1$, we can scan through the circuit and get all values of $\tilde{V}_{i+1}(u)$ when $u \in \{0, 1\}^{s_{i+1}}$, and we have the following equations:
\begin{align*}
{V}_1^1[p](0)=\tilde{V}_{i+1}(0||p)\\
{V}_1^1[p](1)=\tilde{V}_{i+1}(1||p)
\end{align*}
We can solve for ${V}_1^1[p]$ easily.

For ${mult}_1^1$, the idea is the same as ${V}_1^1$, but it's non-trivil to calculate $\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_{i+1}(g, u, v)\tilde{V}_{i+1}(v)$ for every binary $u$ in linear time, since we need to calculate $\tilde{\beta}_{s_{i}}(g, g')$ part in $\tilde{mult}_{i+1}(g, u, v)$. Instead enumerate every binary $u$ to initialize the array, we can enumberate $g'$ instead. And accumulate the contribution of $(g', u', v')$ to $\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_{i+1}(g, u', v)\tilde{V}_{i+1}(v)$. We will use a depth first search to enumerate every $g'$ bit by bit. The detailed algorithm is shown in Algorithm \ref{alg::premult}.
\begin{figure}[p]
\begin{algorithm}[H]
\label{alg::premult}
\caption{Preprocess ${mult}_1^1, {V}_1^1$}
\begin{algorithmic}[1]
\parState{Assuming we have global access to $g$, $s_i$, $s_{i+1}$, which is resonable since prover knows these values, and $g[k]$ means the $k$-th field element of $g$, starting from $0$ since we are writing pseudo-code}
\Procedure{{\sf DFS}}{$A$, $g'$, $depth$, $Value$}
	\parState{Note $A$, $g'$ is the pointer to the array, any change to $A$ or $g'$ will change it globally.}
	\parState{In this function, we will recurse on the bits of $g$}
	\If {$depth=s_{i}$} \Comment{We have enumerate enough bits}
		\State Let $u', v'$ is input gates to $g'$
		\State Find $\tilde{V}_{i+1}(v')$ in circuit.
		\State $A[u'] = A[u'] + \tilde{V}_{i+1}(v')\times Value$
	\Else
		\State set $g'[depth]=0$
		\State Call {\sf DFS}($A$, $g'$, $depth+1$, $Value\times(1-g[depth])$)
		\State set $g'[depth]=1$
		\State Call {\sf DFS}($A$, $g'$, $depth+1$, $Value\times g[depth]$)
	\EndIf
\EndProcedure
\Procedure{{\sf InitializeMult}}{}
	\State Let array ${mult}_1^1$ be filled with zeros.
	\parState{Since calculate $\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_{i+1}(g, u, v)\tilde{V}_{i+1}(v)$ for every binary $u$ is enough to initialize array ${mult}_1^1$, we will call a subroutine to initialize every binary $u$, and store the result into array $A$.}
	\State Initialize array $A$ with zeros.
	\State let $g'$ be a vector of $s_{i+1}$ bits.
	\State Call {\sf DFS}($A$, $g'$, $0$, $1$)
	\For{each $p \in \{0, 1\}^{s_{i+1}-1}$}
		\parState{By solving the linear equations, we can get the following statements}
		\State ${mult}_1^1[p].b=A[0||p]$
		\State ${mult}_1^1[p].a=A[1||p]-A[0||p]$
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{figure}

\paragraph{Answer Queries}
The answer to the first query is the following univariate function:

$$\sum_{p}{mult}_1^1[p](x)\times{V}_1^1[p](x),$$

It's easy to get this result by doing some transformation on the original equation.

We reduce these arraies to the second round using the following way

\begin{enumerate}
	\item By definition, ${mult}_2^1[p'](0)={mult}_1^1[0||p'](r_1)$ and ${mult}_2^1[p'](1)={mult}_1^1[1||p'](r_1)$
	\item By definition, ${V}_2^1[p'](0)={V}_1^1[0||p'](r_1)$ and ${V}_2^1[p'](1)={V}_1^1[1||p'](r_1)$

	\item Since both ${mult}_2^1, {V}_2^1$ are linear equations, we can solve the ${mult}_2^1, {V}_2^1$ by solving linear equations.
	\item By solving linear equations we found that ${mult}_2^1[p'].b={mult}_1^1[0||p'](r_1)$ and ${mult}_2^1[p'].a={mult}_1^1[1||p'](r_1)-{mult}_1^1[0||p'](r_1)$
\end{enumerate}

The answer to the second round is 

$$\sum_{p'}{mult}_2^1[p']\times{V}_2^1[p']$$

We define arrays for the $k$-th round ($k\ge 2$) in the similarly using the result from $k-1$-th round, and solving the linear equation.

The answer to the $k$-th round query is 
$$\sum_{p}{mult}_k^1[p]\times{V}_k^1[p]$$

\begin{theorem} For every round, the algorithm above correctly answered the query. And the running time of the algorithm runs in time $O(\max(2^{s_i}, 2^{s_{i+1}}))$.
\end{theorem}

\begin{proof}
It's trivial to see that ${mult}_k^1, {V}_k^1$ are computed correctly. 

For time complexity part, ${mult}_k^1, {V}_k^1$ are computed in linear time since Algorithm \ref{alg::premult} runs in linear time, and for $k$-th layer, the size of ${mult}_k^1$ is half size of ${mult}_{k-1}^1$, by total size of these arraies is linear to the circuit size.

The answer to the verifier is correct by the definition of ${mult}_k^1, {V}_k^1$.
\end{proof}

\subsubsection{Part two}
In this part, we will deal with next $s_{i+1}$ rounds. In these rounds, $g, u$ are fixed random vector with $s_{i}, s_{i+1}$ random field elements respectively.

\paragraph*{Initialize Arrays}
We define two arrays ${mult}_k^2, {V}_k^2$ analogue to ${mult}_k^1, {V}_k^1$.

\begin{definition}[Linear Function Array Part Two]
	For $k=1$, we define 
	\begin{enumerate}
		\item ${mult}_1^2[p] = \tilde{mult}_i(g, u, \{x_1, p\})\tilde{V}_{i+1}(u)$
		\item ${V}_1^2[p] = \tilde{V}_{i+1}(\{x_1, p\})$
	\end{enumerate}
	For $k\ge 2$, we define
	\begin{enumerate}
		\item ${mult}_k^2[p]\overset{def}{=}\tilde{mult}_i(g, u, \{r_1, ..., r_{k-1}, x_k, p\})\tilde{V}_{i+1}(u)$
		\item ${V}_k^2[p]\overset{def}{=}\tilde{V}_i(\{r_1, ..., r_{k-1}, x_k, p\})$
		\item Where $p$ is a $s_{i+1}-k$ bits binary number and $\{r_1, ..., r_{k-1}, x_k, p\}$ is the representation of $v$.
	\end{enumerate}
\end{definition}

As we discussed in Part One, we only need to calculate all the values of ${mult}_k^2, {V}_k^2$. By the definition of $\tilde{mult}_i(g, u, v)\overset{def}{=}\sum_{g', u', v' \in G_{i, mult}}\tilde{\beta_{s_i}}(g, g')\tilde{\beta_{s_{i+1}}}(u, u')\tilde{\beta_{s_{i+1}}}(v, v')$. We found that $\tilde{mult}_i$ is composed by three seperate functions. Since $g, u$ are fixed random vector, we can preprocess $\tilde{\beta}_{s_i}(g, g')$ for every binary $g'$ and preprocess $\tilde{\beta}_{s_{i+1}}(u, u')$ for every binary $u'$. See the detailed algorithm in Algorithm \ref{alg::parttwo}.

\begin{figure}[p]
\begin{algorithm}[H]
\label{alg::parttwo}
\caption{Preprocess $mult_1^2, V_1^2$}
\begin{algorithmic}[1]
\parState{Array/Vector parameters are passed by pointer, any change to the array will effect the array globally}
\Procedure{{\sf DFS}}{$A, x, randVec, depth, maxDepth, value$}
	\If{$depth=maxDepth$}
		\State $A[x]=value$
	\Else
		\State set $x[depth]=0$
		\State Call DFS($A$, $x$, $depth + 1$, $value \times (1-randVec[depth])$)
		\State set $x[depth]=1$
		\State Call DFS($A$, $x$, $depth + 1$, $value \times randVec[depth]$)
	\EndIf
\EndProcedure
\Procedure{{\sf PreprocessBeta}}{$BetaMult, BetaV$}
	\State let $g', u'$ be zero $s_{i}, s_{i+1}$ length vector
	\State Call {\sf DFS}($BetaMult$, $g'$, $g$, $0$, $s_{i}$, $1$)
	\State Call {\sf DFS}($BetaV$, $u'$, $u$, $0$, $s_{i + 1}$, $1$)
\EndProcedure
\Procedure{{\sf Preprocess}}{${Mult}_1^2, {V}_1^2$}
	\State Let $BetaMult, BetaV$ be a array with length $2^{s_{i}}, 2^{s_{i+1}}$ respectively
	\State Call {\sf PreprocessBeta}($BetaMult$, $BetaV$)
	\State Let $MultBinaryU$ be a array with $2^{s_{i+1}}$ field elements, initially set to $0$.
	\parState{The array $MultBinaryU[v'] \overset{def}{=}\tilde{mult}_i(g, u, v')\tilde{V}_{i+1}(u)$}, we will show that how to compute this array in this For loop.
	\For{Each $v' \in \{0, 1\}^{s_{i+1}}$}
		\For{Each $(g', u')$ that is connected to $v'$ in the circuit}
			\State $MultBinaryU[v'] += BetaMult[g'] \times BetaV[u'] \times \tilde{V}_{i+1}[u]$
			\parState{Since $u$ is a constant, $\tilde{V}_{i+1}[u]$ is a constant all the time as well, we can obtain the value from the result of Part One (It equals to $V_{s_{i+1}-1}^1[0](r_{s_{i+1}})$ by the definition of $V_{k}^1$).}
		\EndFor
	\EndFor

	\For {each $p \in \{0, 1\}^{s_{i+1}-1}$}
		\parState{By solving the linear equations , we can get the following statements}
		\State $Mult_1^2[p].b = MultBinaryU[0||p]$
		\State $Mult_1^2[p].a = MultBinaryU[1||p]-MultBinaryU[0||p]$
		\parState{$\tilde{V}_{s_{i+1}}[v']$ is the value directly from the circuit, we assume it's preprocessed into a array.}
		\State $V_1^2[p].b = \tilde{V}_{s_{i+1}}[0||p]$
		\State $V_1^2[p].a = \tilde{V}_{s_{i+1}}[1||p]-\tilde{V}_{s_{i+1}}[0||p]$
	\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{figure}

\paragraph*{Answer Queries}
The answer to the first query is the following univariate function:

$$\sum_{p}mult_{1}^2[p](x)\times V_1^2[p](x)$$

It's easy to check that this summation is equals to the original sumcheck summation.

To answer $k$-th query ($k\ge 2$), we suppose we have answered the $k-1$-th query and generated arrays $mult_{k-1}^2, V_{k-1}^2$, we generate $mult_{k}^2, V_{k}^2$ and answer the $k$-th query in the following way:

\begin{enumerate}
	\item By definition, $\forall p \in {\{0, 1\}^{s_{i+1}-k}}$, $mult_{k}^2[p](0)=mult_{k-1}^2[0||p](r_{k-1}), mult_{k}^2[p](1)=mult_{k-1}^2[1||p](r_{k-1})$
	\item By definition, $\forall p \in {\{0, 1\}^{s_{i+1}-k}}$, $V_{k}^2[p](0)=V_{k-1}^2[0||p](r_{k-1}), V_{k}^2[p](1)=V_{k-1}^2[1||p](r_{k-1})$
	\item Since $mult_{k}^2[p], V_{k}^2[p]$ are linear function, we can solve the equations above. We have the following results.
	\item $\forall p \in {\{0, 1\}^{s_{i+1}-k}}$, $mult_{k}^2[p].b = mult_{k-1}^2[0||p](r_{k-1}), mult_{k}^2[p].a = mult_{k-1}^2[1||p](r_{k-1})-mult_{k-1}^2[0||p](r_{k-1})$
	\item $\forall p \in {\{0, 1\}^{s_{i+1}-k}}$, $V_{k}^2[p].b = V_{k-1}^2[0||p](r_{k-1}), V_{k}^2[p].a = V_{k-1}^2[1||p](r_{k-1})-V_{k-1}^2[0||p](r_{k-1})$
	\item For $k$-th round, the answer to the query is $\sum_{p} mult_{k}^2[p](x)\times V_{k}^2[p](x)$
\end{enumerate}

\begin{theorem} The algorithm above correctly answered querys of last $s_{i+1}$ rounds, and runs in time $O(\max(2^{s_{i}}, 2^{s_{i+1}}))$.
\end{theorem}

\begin{proof}
Since we only need to scan through the circuit, the time complexity is linear for initialize $mult_{1}^2, V_1^2$. The size of $mult_{k}^2, V_k^2$ is half of $mult_{k-1}^2, V_{k-1}^2$. The total size of $mult_{k}^2, V_k^2$ is linear to the size of $mult_1^2, V_1^2$, which is the circuit size. And to answer the query, we only need to scan through these arrays. The total time complexity is linear to the circuit size.

If $mult_k^2, V_k^2$ are generated correctly, the answer to the query is correct by definition.

$V_1^2$ is correct since it's equal to the circuit value. $mult_1^2$ is correct if and only if $MultBinaryU$ is generated correctly. $\forall g'$, $BetaMult[g']$ is correct because we calculated it bit by bit according to definition in $DFS$ part. And so does $BetaV[u']$. By definition 
\begin{align*}
MultBinaryU[v']&\overset{def}{=}\tilde{mult}_{i}(g, u, v')\tilde{V}_{i+1}(u)
\\&=\sum_{v=v', (g', u', v) \in G_{i, mult}}\tilde{\beta}_{s_{i}}(g, g')\tilde{\beta}_{s_{i+1}}(u, u')\tilde{\beta}_{s_{i+1}}(v, v')\tilde{V}_{i+1}(u)
\\&=\sum_{v=v', (g', u', v) \in G_{i, mult}}\tilde{\beta}_{s_{i}}(g, g')\tilde{\beta}_{s_{i+1}}(u, u')\tilde{V}_{i+1}(u)
\end{align*}

Since $BetaMult[g'], BetaV[u']$ are correct, we have $MultBinaryU$ is correct. Thus $mult_1^2$ is correct.

To prove $mult_k^2, V_k^2$ is correct ($k \ge 2$). We assume $mult_{k-1}^2, V_{k-1}^2$ is correct. According to the definition of $mult_k^2$, $mult_k^2[p](0)=\tilde{mult}_i(g, u, {r_1, r_2,...,r_{k-1}, 0, p})=mult_{k-1}^2[0||p](r_{k-1})$, $mult_k^2[p](1)=\tilde{mult}_i(g, u, {r_1, r_2,...,r_{k-1}, 1, p})=mult_{k-1}^2[1||p](r_{k-1})$, by solving the linear equation, we can get the right value of $mult_k^2[p]$. And we have a similar arguement of $V_k^2$.
\end{proof}

\subsubsection{Combining two points}
In original CMT protocol, after the final round of sumcheck, we have two claimed value about the next layer, $\tilde{V}_{i+1}(u), \tilde{V}_{i+1}(v)$ where $u, v$ are random vector from sumcheck. We can setup a line $\gamma(x)$ where $\gamma(0) = u, \gamma(1)=v$. The prover need to provide $\tilde{V}_{i+1}(\gamma(x))$ to verifier, and the verifier can chooses next random point.

Unfortunately, if the prover naively compute $\tilde{V}_{i+1}(\gamma(x))$, it would incur $O(2^{s_{i+1}}s_{i+1})$ complexity. To optimize the computing, we need to look at the structure of the summation. 

\begin{align*}
\tilde{V}_{i+1}(\gamma(x))&=\sum_{u, v \in \{0, 1\}^{s_{i+1}}}\tilde{mult}_{i+1}(\gamma(x), u, v)\tilde{V}_{i+2}(u)\tilde{V}_{i+2}(v)\\
&=\sum_{u, v\in \{0, 1\}^{s_{i+1}}}\sum_{(g', u', v') \in G_{i+1, mult}}\tilde{\beta}_{s_{i+1}}(\gamma(x), g')\tilde{\beta}_{s_{i+2}}(u, u')\tilde{\beta}_{s_{i+2}}(v, v')\tilde{V}_{i+2}(u)\tilde{V}_{i+2}(v)
\end{align*}

The interesting thing is that, $\tilde{\beta}_{s_{i+1}}(\gamma(x), g')\tilde{\beta}_{s_{i+2}}(u, u')\tilde{\beta}_{s_{i+2}}(v, v')\tilde{V}_{i+2}(u)\tilde{V}_{i+2}(v)$ is non-zero if and only if $u=u', v=v'$. Thus we can optimize the summation to :

$$\tilde{V}_{i+1}(\gamma(x))=\sum_{(g', u', v') \in G_{i+1, mult}}\tilde{\beta}_{s_{i+1}}(\gamma(x), g')\tilde{V}_{i+2}(u')\tilde{V}_{i+2}(v').$$ Now we present a efficient algorithm \ref{alg::comb} to calculate this summation.

\begin{figure}[p]
\begin{algorithm}[H]
\label{alg::comb}
\caption{Calculate $\tilde{V}_{i+1}(\gamma(x))$}
\begin{algorithmic}[1]
\parState{We define a polynomial type here to represent a polynomial. The cost of mutiplying two polynomials with degree $d_1, d_2$ is $d_1\times d_2$, and the cost of evaluating a polynomial with degree $d$ is $d+1$.}
\Procedure{{\sf DFS}}{$g$, $G$, $depth$, $maxDepth$}
	\If{$depth=maxDepth$}
		\State Return $Poly(G[g])$
	\Else
		\State $sum = Poly(0)$
		\State set $g[depth]=0$
		\State $polyleft = DFS(g, G, depth + 1, maxDepth) \times (1-\gamma[depth](x))$
		\State set $g[depth]=1$
		\State $polyright = DFS(g, G, depth + 1, maxDepth) \times \gamma[depth](x)$
		\State $sum = polyleft + polyright$
		\State Return $sum$
	\EndIf
\EndProcedure
\Procedure{{\sf Combine}}{$\gamma$}
\parState{Here $\gamma$ is a pair array with length $s_{i+1}$, a pair $(a, b)$ can be treated as a pair or a linear function $ax+b$, we will use both notation interchangely.}
\State Let $G[g]$ be a array with $2^{s_{i+1}}$ elements
\State $G[g]\overset{def}{=}\sum_{g'=g, (g', u', v')\in G_{i+1, mult}}\tilde{V}_{i+1}(u')\tilde{V}_{i+1}(v')$.
\State $G[g]$ can be computed by a single scan through the circuit. We assume it's initialized apporiately.
\State The answer is $\sum_{g \in \{0, 1\}^{s_{i+1}}}G[g]\times \tilde{\beta}_{s_{i+1}}(\gamma(x), g)$, we will show that how to compute this answer in linear time.

\State Return {\sf DFS}($\vec{0}$, G, $0$, $s_{i+1}$)
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{figure}
\paragraph*{An Alternative Way}
There is another way to deal with this problem. This approach is proposed by Alessandro et al.\cite{zksumcheck} In the first round, the sumcheck protocol will eventually reduce to two random claims $\tilde{V}_{2}(u), \tilde{V}_2(v)$. Their protocol just recursively check these two claims parallelly with shared randomness. These two sub thread will run the sumcheck protocol, and eventually reduced to $\tilde{V}_{3}(u_1), \tilde{V}_{3}(v_1), \tilde{V}_{3}(u_2), \tilde{V}_{3}(v_2)$. Since they share the same randomness, we have $u_1=u_2, v_1=v_2$. In this case, the size of recursion will not change. And for next rounds of both recursion thread, they still share the same randomness. The size of recursion will not grow at all. Applying our linear time sumcheck, this algorithm will be linear time.