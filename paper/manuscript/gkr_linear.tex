%!TEX root = fastZKP.tex
\section{Linear Prover Time GKR Protocol}
\label{sec::gkrlin}
In this section we will improve the GKR protocol\cite{GKR} to make the prover runs in linear time. Our work is based on the CMT protocol \cite{CMT}.

\subsection{Roadmap}
Through out the whole CMT protocol, the prover has to answer two type of queries:
\begin{enumerate}
	\item the query related to sumcheck.
	\item the query to combine the points. 
\end{enumerate}

We will deal with these queries seperately. The equation in sumcheck queries are well structured. For each sumcheck we are going to check the claim $a_i=\tilde{V_i}(r_i)$. Since the sumcheck deal with the parameters one by one, we can divide the sumcheck into two stages as follows: the first stage is the sumcheck about variables in $u$ and the second stage is the sumcheck about the variaibles in $v$. Also notice that $\tilde{mult}$ and $\tilde{add}$ are independent in the equation, where independent means that we can calculate them seperately and the final answer is the sum of these two. So we can treat them seperately using two similar algorithm. For simplicity, in this subsection we only discuss the idea of calculate $\tilde{mult}$ part. 

For a generic sumcheck protocol, if we can initialize all binary values to an array, we can answer the first sumcheck query by scanning through the array, and reduce the array into a new array with only half size of the previous array since the summation size in the sumcheck is halved. By reducing the array, we can answer all queries in linear time to the initial array size.

Unfortunatelly, we cannot directly use this technique to our protocol since if we directly initialize the array, the time complexity would be the square of the current layer size since we have two variables. But notice that the array is extremely sparse, and the equation is well structured, we still have the chance to optimize the computation.

For the combination part, it's quite straightforward, we defer the introduction to the detailed protocol.

\subsection{Detailed Protocol}
We will follow the CMT protocol, and improve the performance of sumcheck and the performance of combining two points.
\subsubsection{Linear Prover Time Sumcheck}
\paragraph{Review the sumcheck}
In this subsection, we focus on answering the sumcheck queries. In the first round, the verifier asks the prover to give a univariate function: 

$$f_{i, 1}(x_1)=\sum_{u_{k} \in \{0, 1\}, v \in \{0, 1\}^{s_{i+1}}}\tilde{mult}_{i}(g, \{x_1, u_{2},..., u_{s_{i+1}}\}, v)(\tilde{V}_{i+1}(x_1, u_{2},..., u_{|u|})\tilde{V}_{i+1}(v)),$$
where $v$ is a binary vector in $\{0, 1\}^{s_{i+1}}$, $\{x_1, u_{2},..., u_{s_{i+1}}\}$ is the representation of $u$.

In the $k$-th round where $2\le k\le s_{i+1}$, the verifier asks the prover to give a univariate function:
\begin{align*}
f_{i,k}(x_k)=\sum_{u_k \in \{0, 1\}, v \in \{0, 1\}^{s_{i+1}}}\tilde{mult}_{i}(g, \{r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}}\}, v)\times\\
(\tilde{V}_{i+1}(r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}})\tilde{V}_{i+1}(v))
\end{align*}
where $v$ is a binary vector in $\{0, 1\}^{s_{i+1}}$, $\{r_1,r_2,...,r_{k-1},x_k, u_{k+1},..., u_{s_{i+1}}\}$ is the representation of $u$.

\paragraph{Definition and analysis of building blocks}
In the first round, we calculate two arraies, where each array element is a pair $(a, b)$ representing a linear function $ax+b$.

The first array is $\overline{mult}_1$, where $\overline{mult}_1[p]$ is a pair $(a, b)$ representing a linear function as follows:
$$\overline{mult}_1[p]\overset{def}{=}\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_i(g, \{x_1, p\}, v)\tilde{V}_{i+1}(v),$$
here $p$ is a $s_{i+1}-1$ bits binary number. $\{x_1, p\}$ is the representation of $u$. Similarly we define our second array $\overline{V}_1[p]$ as follows:
$$\overline{V}_1[p]\overset{def}{=}\tilde{V}_i(\{x_1, p\})$$

We will treat both arrays as a linear function or a pair of field elements interchangeably, for example $\overline{mult}_k[p](x)$ means we treat it as a linear function, and $\overline{mult}_k[p].a, \overline{mult}_k[p].b$ means we treat it as a pair.

The answer to the first query is the following univariate function:

$$\sum_{p}\overline{mult}_1[p](x)\times\overline{V}_1[p](x),$$

It's easy to get this result by doing some transformation on the original equation.

And we reduce these arraies to the second round using the following way

\begin{enumerate}
	\item Observe that $\overline{mult}_2[p'](0)=\overline{mult}_1[0||p'](r_1)$ and $\overline{mult}_2[p'](1)=\overline{mult}_1[1||p'](r_1)$
	\item Observe that $\overline{V}_2[p'](0)=\overline{V}_1[0||p'](r_1)$ and $\overline{V}_2[p'](1)=\overline{V}_1[1||p'](r_1)$

	\item Since both $\overline{mult}, \overline{V}$ are linear equations, we can solve the $\overline{mult}_2, \overline{V}_2$ by solving linear equations.
	\item By solving linear equations we found that $\overline{mult}_2[p'].b=\overline{mult}_1[0||p'](r_1)$ and $\overline{mult}_2[p'].a=\overline{mult}_1[1||p'](r_1)-\overline{mult}_1[0||p'](r_1)$
\end{enumerate}

Where $p'$ is a $s_{i+1}-2$ bit binary number. And the answer to the second round is 

$$\sum_{p'}\overline{mult}_2[p']\times\overline{V}_2[p']$$

We define arrays for the $k$-th round ($k\ge 2$) in the similarly using the result from $k-1$-th round.

The answer to the $k$-th round query is 
$$\sum_{p}\overline{mult}_k[p]\times\overline{V}_k[p]$$

\begin{theorem} For every round, the algorithm above correctly answered the query.
\end{theorem}

\begin{proof}
For $1$-st round, we have the following invariant holds by definition:
$$\overline{mult}_1[p]{=}\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_i(g, \{x_1, p\}, v)\tilde{V}_{i+1}(v)$$
$$\overline{V}_1[p]{=}\tilde{V}_i(\{x_1, p\})$$

Suppose in $k-1$-th round ($i \ge 2$), the following invariant holds:
$$\overline{mult}_{k-1}[p]{=}\sum_{v\in \{0,1\}^{s_{i+1}}}\tilde{mult}_i(g, \{r_1,r_2,...,r_{k-2},x_{k-1}, p\}, v)\tilde{V}_{i+1}(v)$$
$$\overline{V}_{k-1}[p]{=}\tilde{V}_i(\{r_1, r_2,...,r_{k-2},x_{k-1}, p\})$$

We can conclude that $$$$

\end{proof}

\paragraph{Initialize the array}
$\overline{mult}_1, \overline{V}_1$ can be initialized in linear time using the following algorithm
\subsubsection{Combine two points}
\subsubsection{Running Time Analysis}