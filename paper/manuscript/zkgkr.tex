%!TEX root = fastZKP.tex

\section{Zero Knowledge Argument Protocols}

In this section, we present the zero-knowledge version of our argument scheme. Recall that our scheme has two building blocks: the GKR protocol and the VPD protocol. We show how to make each of them zero-knowledge efficiently.

\subsection{Zero Knowledge Sumcheck}\label{ZKSumcheck}
As a core step of the GKR protocol, the prover and the verifier execute a sumcheck protocol, during which the prover sends the verifier evaluations of polynomial~\ref{def::multilinear} at several random points chosen by the verifier. These evaluations leak information about the the values in the circuit, as they can be viewed as weighted sum on the values in each layer. Therefore, as the first step, we propose a zero-knowledge version of the sumcheck protocol. 

We take the approach proposed by Chiesa et. al in \cite{zksumcheck}, which is to mask the polynomial in the sumcheck protocol by a random polynomial. In this approach, to prove $a = \sum\limits_{x_1, x_2, \cdots, x_n \in \{0, 1\}}F(x_1, x_2, \cdots, x_l)$, the prover generates a random polynomial $G$ with the same variables and individual degrees of $F$. He commits to the polynomial $G$, and sends the verifier a claim $b = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}}G(x_1, x_2, \cdots, x_l)$. The verifier picks a random number $\rho$, and execute a sumcheck protocol with the prover on $$a + \rho b = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}}(F(x_1, x_2, \cdots, x_l) + \rho G(x_1, x_2, \cdots, x_l)).$$ At the last round of the sumcheck, the prover opens the commitment of $G$ at $G(r_1, \ldots, r_l)$, and the verifier computes $F(r_1, \ldots, r_l)$ by subtracting $\rho G(r_1, \ldots, r_l)$ from the last message, and compares it with the oracle access of $F$. It is shown that as long as the commitment and opening of $G$ are zero-knowledge, the protocol is zero-knowledge, because all the coefficients of $F$ are masked by those of $G$. The soundness still hold because of the random linear combination of $F$ and $G$. 

Unfortunately, however, the masking polynomial $G$ is as big as $F$, and opening it to a random point later is expensive. In~\cite{zksumcheck}, the prover sends a PCP oracle of $G$, and executes a zero-knowledge sumcheck to open it to a random point, which incurs an exponential complexity for the prover. Even replacing it with our VPD protocol, the prover time is slow in practice.

In this paper, we show that we can mask $F$ with a much smaller polynomial to achieve zero-knowledge. In particular, it suffices to set $G(x_1, \ldots, x_\ell) = a_{0} + G_1(x_1) + G_2(x_2) + \ldots + G_l(x_l)$, where $G_{i}(x_i) = a_{i1}x_i + a_{i2}x_i^2 + \ldots + a_{id}x_i^d$ is a random univariate polynomial of degree $d$ ($d$ is the variable degree of $F$). Note here that the size of $G$ is only $O(dl)$, while the size of $F$ is exponential in $l$ ($O(2^l)$ in the GKR protocol with $d=2$).

The intuition of this optimization is that the prover sends $O(dl)$ messages in total to the verifier during the sumcheck protocol, thus a polynomial $G$ with $O(dl)$ random coefficients is sufficient to mask all the messages and achieve zero-knowledge. We present the full protocol in the following.


\medskip\noindent\textbf{Protocol.}

We assume a blackbox of zero-knowledge polynomial commitments and evaluations, which will be presented in Section~\ref{sec::zkvpd}. To prove the claim $a = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}} F(x_1, x_2, \cdots, x_l)$:
\begin{enumerate}

\item $\mathcal{P}$ selects a polynomial $G(x_1,\ldots, x_l) = a_{0} + G_1(x_1) + G_2(x_2) + \cdots + G_l(x_l)$, where $G_{i}(x_i) = a_{i1}x_i + a_{i2}x_i^2 + \cdots + a_{id}x_i^d$ and all $a_{ij}$s are uniformly random. $\mathcal{P}$ sends $a = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}} F(x_1, x_2, \cdots, x_l)$ and $b = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}} G(x_1, x_2, \cdots, x_l)$ to $\mathcal{V}$, and commits to $G(x_1,\ldots, x_l)$. 
\item $\mathcal{V}$ uniformly sample $\rho \in \mathbb{F}/\{0\}$, and sends $\rho$ to $\mathcal{P}$.
\item $\mathcal{P}$ and $\mathcal{V}$ run the sumcheck protocol on the claim
$$a + \rho b = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}}(F(x_1, x_2, \cdots, x_l) + \rho G(x_1, x_2, \cdots, x_l))$$
\item At the last round of the sumcheck protocol, $\mathcal{V}$ obtains a claim $h_l(r_l) = F(r_1, r_2, \cdots, r_l)+\rho G(r_1, r_2, \cdots, r_l)$. $\mathcal{V}$ opens the commitment of $G$ at $(r_1,\ldots, r_l)$. $\mathcal{V}$ computes $h_l(r_l)-\rho G(r_1,\ldots,r_l)$ and accepts if it equals to the oracle access of $F(r_1,\ldots, r_l)$.

\end{enumerate}

The completeness of the protocol holds obviously. The soundness of the protocol follows the soundness of the sumcheck protocol and the random linear combination, as proven in~\cite{zksumcheck}. We give a proof of zero-knowledge here.

\medskip\noindent\textbf{Zero knowledge}. We prove that the protocol has perfect zero knowledge by exhibiting a polynomial-time simulator $\mathcal{S}$ with $a = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}}F(x_1, x_2, \cdots, x_l)$ that perfectly samples the view of any malicious verifier. The simulator $\mathcal{S}$ given straightline access to $\mathcal{V^*}$, works as follows.

\begin{enumerate}

\item Draw a multilinear polynomial $Z_{sim} = a_{0} + Z_{sim_1}(x_1) + Z_{sim_2}(x_2) + \cdots + Z_{sim_l}(x_l)$, where $Z_{sim_i}(x_i) = a_{i1}x_i + a_{i2}x_i^2 + \cdots + a_{id}x_i^d$ at random. 

\item Begin simulating $\mathcal{V}^*$. The simulator sends $a$ and $b = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}}Z_{sim}(x_1, x_2, \cdots, x_l)$ to $\mathcal{V}^*$.

\item $\mathcal{S}$ receives $\rho \neq 0$ from $\mathcal{V^*}$. Draw a polynomial $Q_{sim} \in \mathbb{F}[x_{1, 2, \cdots, n}^{\leqslant d}]$ uniform at random conditioned on $$ \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}}Q_{sim}(x_1, x_2, \cdots, x_l) = a + \rho b$$ 

Then engage in the sumcheck protocol on the claim $$\sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}}Q_{sim}(x_1, x_2, \cdots, x_l) = a + \rho b$$

\item Let $\vec{r} \in \mathbb{F}^n$ be the point chosen by $\mathcal{V}^*$ in the sumcheck protocol. $\mathcal{V}^*$ queries the oracle to get $s = Q_{sim}(\vec{r}) - \rho Z_{sim}(\vec{r})$ and $t = Z_{sim}(\vec{r})$. 

\item Output the view of the simulated $\mathcal{V}^*$.
\end{enumerate} 

If we would like to prove this protocol is perfect zero knowledge, we need to argue that in the real world, the view of the verifier is the same distributions of the simulator $\mathcal{S}$. Note that the view of the verifier consists of $b$ and $h_i(x_i)$ in every round of the sumcheck protocol.

In fact, the verifier receives $b$ in the beginning. Then in every round $i$ of the sumcheck, the verifier only receives $h_i(0) = f_i(0) + \rho g_i(0), h_i(1) = f_i(1) + \rho g_i(1), \cdots, h_i(d) = f_i(d) + \rho g_i(d)$. Since the verifier knows $h_{i-1}(0), h_{i-1}(1), \cdots, h_{i-1}(d)$ and the random number $r_{i-1}$ in previous round, the verifier could get $h_{i}(0)$ itself if he knows $h_{i}(1)$ as $h_{i}(0) + h_i(1) = h_{i-1}(r_{i-1})$ for honest prover and the veifier could calculate $h_{i-1}(r_{i-1})$ itself. So the actual valid information for the verifier is $h_{1}(1), \cdots, h_{1}(d), h_{2}(1), \cdots, h_2(d), \cdots, h_{n}(1), \cdots, h_{n}(d)$. \\

For the simulator, all of the information is random since $Q_{sim}$ is uniformly chosen at random. We hope that in the real world, all of the information is also random since all coefficients of $G$ are random and independent with $F$. In other words, that is equavilent to $g_{1}(1), \cdots, g_{1}(d), g_{2}(1), \cdots, g_2(d), \cdots$, $g_{n}(1), \cdots, g_{n}(d)$. are linearly independent about random variables $a_0$ and $a_{ij}(1 \leq i \leq n, 1 \leq j \leq d)$. Then the veiw of the verifier should be the same whenever in the simulated world or the real world. 

\begin{proof}
Consider that if we run the sumcheck only for $G(x_1, x_2, \cdots, x_l)$. The verifier could know exactly what $G(x_1, x_2, \cdots, x_l)$ is. The reason is that the verifier could know $g_{i}(0), g_{i}(1), \cdots, g_{i}(d)$ in round $i$, and $G$ is a function of $x_i$ with degree at most $d$, so it is easy to compute the coefficient of $x_i, x^2_i, \cdots, x^d_i$, which are exact $a_{i1}, a_{i2}, \cdots, a_{id}$. Finally, since the verifier knows $b = \sum\limits_{x_1, x_2, \cdots, x_l \in \{0, 1\}}G(x_1, x_2, \cdots, x_l)$, he could compute $a_0$. So the verifier could get the exact function $G$ after the sumcheck protocol.\\  

Notice that in this sumcheck, the valid information for the verifier is still $b, g_i(j)(1 \leq i \leq n, 1 \leq j \leq d)$. The verifier has only $nd + 1$ equations about $nd + 1$ variables and could get the exact value of $a_0$ and $a_{ij}(1 \leq i \leq n, 1 \leq j \leq d)$. Therefore, $b, g_i(j)(1 \leq i \leq n, 1 \leq j \leq d)$ must be linear independent about random variables $a_0$ and $a_{ij}(1 \leq i \leq n, 1 \leq j \leq d)$.
\end{proof}

That means the $b$ and $h_i(x_i)$ are inditinguishable for any verifier. We could know that $\{View_{V^*}(\mathcal{P}(a, F) \leftrightarrow \mathcal{V^*}(a))\} \simeq_{c} \{\mathcal{S}^{\mathcal{V^*}}(a)\}$, which means it is zero knowledge.\\


\subsection{Zero knowledge GKR}

After replacing the sumcheck protocol in GRK with the zero-knowledge version described above, it still leaks some additional information. Specifically, as shown in equation \ref{def::multilinear}, at the end of the sumcheck protocol in each layer of the circuit, the prover sends $\tilde{V}_{i+1}(R_u)$ and $\tilde{V}_{i+1}(R_v)$ to the verifier, which are two evaluations of the polynomial $\tV_{i+1}$ defined by the values in the $(i+1)$-th layer of the circuit. 

To prevent this leakage, Chiesa et al.\cite{zksumcheck} proposed a method to replace the multi-linear extension of $V$ with a special low degree extension, such that learning $\tilde{V}_{i+1}(R_u)$ and $\tilde{V}_{i+1}(R_v)$ does not leak any information about $V$. In particular, they define a low degree extension of $V_i$ as 

\[
\dot{V}_{i}(z) \overset{def}{=} \tV_i(z)+Z_i(z)\sum\limits_{c \in \{0, 1\}^k}R_i(z, c),
\]
where $Z(z) = \prod_{i=1}^l z_i(1-z_i)$, i.e., $Z(z)=0$ for all $z\in\{0, 1\}^{s_i}$. $R_i(z,c)$ is a random low-degree polynomial and $k$ is the security parameter. 

With this low degree extension, the sumcheck protocol in GKR can be written as

\begin{align*}
\dot{V}_{i}(z)=\sum_{u, v\in \{0,1\}^{s_{i+1}}}\tilde{mult}(z, u, v)(\dot{V}_{i+1}(u)\dot{V}_{i+1}(v))&+\tilde{add}(z,u,v)(\dot{V}_{i+1}(u)+\dot{V}_{i+1}(v))\\
&+ Z_i(z)\sum\limits_{c \in \{0, 1\}^k}R_i(z, c)\\
\end{align*}

\begin{align*}
=\sum_{u, v\in \{0,1\}^{s_{i+1}},c \in \{0, 1\}^k}(I(\vec{0},c) \cdot \tilde{mult}(z, u, v)(\dot{V}_{i+1}(u)\dot{V}_{i+1}(v))&+\tilde{add}(z,u,v)(\dot{V}_{i+1}(u)+\dot{V}_{i+1}(v))\\
&+ I((u, v), \vec{0})Z_i(z)R_i(z, c))
\end{align*}
where $I(x,y)$ is an identity polynomial: $I(x,y) = 0$ iff $x=y$. By running the zero-knowledge version of this sumcheck protocol, at the end, the verifier would receive $\dot{V}_{i+1}(R_u)$ and $\dot{V}_{i+1}(R_v)$. They no longer leak information about $V_{i+1}$, as it is masked by $Z_{i+1}(z)\sum\limits_{c \in \{0, 1\}^k}R_{i+1}(z, c)$ for $z=R_u$ and $z=R_v$.

Unfortunately, similar to the zero-knowledge sumcheck, the masking polynomail $R$ is very large in~\cite{zksumcheck}. Opening $R$ at a random point is also very expensive: it takes exponential time in~\cite{zksumcheck} using either PCP oracles or VPD, as $R$ has $s_i+2s_{i+1}+k$ variables.

In this paper, we show that we can set $R$ to be a small polynomial to achieve zero-knowledge. In particular, $R$ has only two variables with variable degree 2. This is because in the $(i-1)$-th sumcheck the verifier receives two evaluations of $V_i$ masked by $\sum_{c}R_i(R_u,c)$ and $\sum_{c}R_i(R_u,c)$, and in the $i$-th sumcheck, the verifier opens it at $\alpha R_i(R_u,R_c)+\beta R_i(R_v,R_c)$. It suffices to make these three evaluations linearly independent, given the blackbox of zero-knowledge polynomial evaluation of $R_i$. We present the protocol in detail below.



\medskip\noindent\textbf{Protocol.}
\begin{enumerate} 
\item The prover $\mathcal{P}$ gives $\text{Output}$ of the circuit $\dot{V}_0(0)$ to the verifier $\mathcal{V}$. 
\item $\mathcal{P}$ samples $R_1(X, Y), R_2(X, Y), \cdots, R_d(X, Y)$ randomly from $\mathbb{F}[X^{\leqslant 2}, Y^{\leqslant 2}]$
\item $\mathcal{P}$ and $\mathcal{V}$ run the zero knowledge sumcheck protocol on the claim:
$$\dot{V}_0(0) = \sum_{u, v\in \{0,1\}^{s_1}}\tilde{mult}(0, u, v)(\dot{V}_1(u)\dot{V}_1(v))+\tilde{add}(0,u,v)(\dot{V}_1(u)+\dot{V}_1(v))$$

At the end of the sumcheck protocol, $\mathcal{P}$ sends $\dot{V}_1(r)$ and $\dot{V}_1(s)$ to $\mathcal{V}$ if $r_1 \neq s_1$, where $r, s$ are randomly chosen by $\mathcal{V}$, If $r_1 = s_1$ $\mathcal{P}$ aborts. If it does not pass the sum check protocol, $\mathcal{V}$ rejects. 

\item For layer $i(1 \leq i \leq d - 1)$:
	\begin{itemize}
	\item $\mathcal{V}$ samples $\alpha_1, \alpha_2$ at random and sends them to $\mathcal{P}$.
	\item $\mathcal{V}$ and $\mathcal{P}$ run the zero knowledge sumcheck on the claim
	$$\alpha_1 \dot{V}_i(r) + \alpha_2 \dot{V}_i(s) = \alpha_1 a_{r} + \alpha_2 a_{s}$$
	Let $z^{(1)} = r$ and $z^{(2)} = s$.
	\item At the end of the sumcheck protocol, $\mathcal{P}$ receives the random vector $r, s, p$ with $r, s \in (\mathbb{F} - \{0, 1\})^{s_{i+1}}$ and $p \in \mathbb{F}$. 
	\begin{align*}
		\sum_{j = 1, 2} \alpha_j (\tilde{mult}(z^{(j)}, r, s)(\dot{V}_{i+1}(r)\dot{V}_{i+1}(s))&+\tilde{add}(z^{(j)},r,s)(\dot{V}_{i+1}(r)+\dot{V}_{i+1}(s))\\
 		&+ Z_i(z^{(j)})\sum\limits_{c \in \{0, 1\}}R_i(z^{(j)}_1, c))
	\end{align*}
	\item If $r_1 = s_1$, abort. 
	\item $\mathcal{P}$ replies with the value $a_r = \dot{V}_{i+1}(r)$, $a_s = \dot{V}_{i+1}(s)$.
	\item $\mathcal{V}$ queries the oracle to get $a = R_i(z^{(1)}_1, p)$ and $b = R_i(z^{(2)}_1, p)$. If $\mathcal{P}$ does not pass the sumcheck protocol, $\mathcal{V}$ rejects.
	\end{itemize}

\item For input layer $d$, $\mathcal{V}$ queries the oracle to verify the claim $\dot{V}_d(r) = \tilde{V}_d(r) + Z(r)\sum\limits_{c \in \{0, 1\}}R_d(r_1, c)$ and $\dot{V}_d(s) = \tilde{V}_d(s) + Z(s)\sum\limits_{c \in \{0, 1\}}R_d(s_1, c)$. $\mathcal{V}$ accepts if it passes the final verification. Otherwise, $\mathcal{V}$ rejects. 
\end{enumerate}

\noindent
\textbf{Completeness}. The completeness property immediately follows from the construction of the protocol and the completeness of zero knowledge sumcheck. We now proceed to argue about the soundness.\\

\noindent
\textbf{Soundness}. Let $\mathcal{P}^*$ be an cheating prover which convinces $\mathcal{V}$ of a claim ``Output = C(Input)'' for some Input and C such that Output $\neq$ C(Input). That means $\dot{V_0(0)} \neq \text{Output}$ in the beginning of the protocol. Supoose that we omit the soundness of the oracle since all of them are negligible of $\lambda = \log |\mathbb{F}|$. We claim that if there exists $\dot{V}_i(r) \neq a_r$, then after this iteration with high probability either $(a)$ $\mathcal{V}$ rejects, or $(b)$ in the next iteration, $\dot{V}_{i+1}(r) \neq a_r$ or $\dot{V}_{i+1}(s) \neq a_s$. Since $\alpha_1$ and $\alpha_2$ are randomly chosen by $\mathcal{V}$, the probability that $\alpha_1 \dot{V}_i(r) + \alpha_2 \dot{V}_i(s) = \alpha_1 a_{r} + \alpha_2 a_{s}$ is $1/|\mathbb{F}|$ if $\dot{V}_i(r) \neq a_r$. Besides, according to the soundness of sumcheck protobol, when we run the protocol on a false claim with $2s_{i+1} + 1 \leq 3 \log S$ variables and individual degree at most 2, the verifier $\mathcal{V}$ either rejects or passses the false claim to the next iteration with probability $1 - 6 \log S / (|\mathbb{F}| - 2)$.\\

That is to say, if $C(\text{Input}) \neq \dot{V}_0(0)$, the verifier $\mathcal{V}$ will accept with probability at most $\mathcal{O}(d \log S / |\mathcal{F}|)$, where $d$ is the depth of $C$ and $S$ is the maximum number of gates in one layer of $C$. Hence, the total soundness of the zero knowledge GKR protocol is negligible of $\lambda$.\\

\noindent
\textbf{Zero knowledge}. We prove that the protocol has perfect zero knowledge by exhibiting a polynomial-time simulator $\mathcal{S}$ with $\text{Ouptut}$ and the circuit $C$ that perfectly samples the view of any malicious verifier. 

\begin{enumerate}

\item For every layer $i(1 \leq i \leq d)$ and the function $\dot{V}_i(z)$, sample $R_i^{sim} \in \mathbb{F}[X^{\leqslant 2}, Y^{\leqslant 2}]$ uniformly at random satisfying some conditions. Use $R_i^{sim}$ to answer queries to $R_i$.

\item For every layer function $\dot{V}_i(z)$, run the zero knowledge sumcheck subsimulator for the sumcheck of $\dot{V}_i(z)$, and use it to answer quries of the verifier $\mathcal{V}^*$. 

\item For the output layer(layer $0$), run the zero knowledge sumcheck subsimulator on the claim

$$\text{Output} = \dot{V}_0(0) = \sum_{u, v\in \{0,1\}^{s_1}}\tilde{mult}(0, u, v)(\dot{V}_1(u)\dot{V}_1(v))+\tilde{add}(0,u,v)(\dot{V}_1(u)+\dot{V}_1(v))$$ 
At the end of the zero knowledge sumcheck protocol, the simulator receives the random vector $q = (r, s)$ with with $r, s \in \mathbb{F}^{s_1}$. If $r_1 = s_1$, abort. Otherwise, sample $\dot{V}_1(r)$ and $\dot{V}_1(s)$ at random conditioned on satifying the sumcheck protocol. 
\item For layer $i(1 \leq i \leq d - 1)$:
	\begin{itemize}
	\item Receive $\alpha_1$ and $\alpha_2$ from the verifier.
	\item Using the subsimulator for $\dot{V}_i$, simulate the strong zero knowledge sumcheck protocol on the claim
	$$\alpha_1 \dot{V}_i(r) + \alpha_2 \dot{V}_i(s) = \alpha_1 a_{r} + \alpha_2 a_{s}$$
	Let $z^{(1)} = r$ and $z^{(2)} = s$. 
	\item Then the simulator receives the random vector $q = (r, s, p)$ with $r, s \in (\mathbb{F}-\{0, 1\})^{s_{i+1}}$ and $p \in \mathbb{F}$. 
	\item If $r_1 = s_1$, abort. 
	\item Otherwise, reply with the value
	\begin{align}
		\sum_{j = 1, 2} \alpha_j (\tilde{mult}(z^{(j)}, r, s)(\dot{V}_{i+1}(r)\dot{V}_{i+1}(s))&+\tilde{add}(z^{(j)},r,s)(\dot{V}_{i+1}(r)+\dot{V}_{i+1}(s))\\
 		&+ Z_i(z^{(j)})\sum\limits_{c \in \{0, 1\}}R_i(z_1^{(j)}, c))
	\end{align}
	\item Sample $\dot{V}_{i+1}(r)$ and $\dot{V}_{i+1}(s)$ at random. And randomly choose the function $R^{sim}_i(X, Y)$ satisfying the above claim. The verifier queries the oracle to get $R^{sim}_i(z_1^{(1)}, p)$ and $R^{sim}_i(z_1^{(2)}, p)$.   
	\end{itemize}
\item For input layer $d$, the verifier queries the oracle to verify the values of $\dot{V}_d(r)$ and $\dot{V}_d(s)$.
\end{enumerate} 

If we want to make it zero knowledge, we need to prove that $\{View_{V^*}(\mathcal{P}(\text{Output, C, Input}) \leftrightarrow \mathcal{V^*}(\text{Output, C}))\} = \{\mathcal{S}^{\mathcal{V^*}}(\text{Output, C})\}$. We claim that in the real world execution, the distribution of $\dot{V}_i(r)$ and $\dot{V}_i(s)$ are also uniformly at random in $\mathbb{F}$. In the real world, for every mask function $R_i$, the verifier only knows the value of $R_i(r_1, p)$ and $R_i(s_1, p)$, where $r_1 \neq s_1$ and $r_1, s_1, p$ are randomly chosen by the verifier. If the verifier still have any no idea about the value of $\sum\limits_{c \in \{0, 1\}}R_i(r_1, c)$ and $\sum\limits_{c \in \{0, 1\}}R_i(s_1, c)$ conditioned on it, then $\dot{V}_i(r)$ and $\dot{V}_i(s)$ are uniformly at random.\\

Therefore, we only need to claim that $R(x, p), R(y, p), \sum\limits_{c \in \{0, 1\}}R(x, c), \sum\limits_{c \in \{0, 1\}}R(y, c)$ are independent if $R(x, y)$ are uniformly sampled from $\mathbb{F}[X^{\leqslant 2}, Y^{\leqslant 2}]$ and $x \neq y$. That is obvious since $x \neq y$ and both of the degrees of $X, Y$ are two.\\

Other things are also distinguishable for the verifier $\mathcal{V^*}$ because of the zero knowledge oracle(ZK VPD) and the zero knowledge sumcheck protocol. So our entire protocol is zero knowledge, which completes our proof.\\

\noindent
\textbf{Complexity}. Consider the time complexity of zero knowledge GKR protocol. We would like to focus on the prover time. Since we have analyzed the prover time in our linear GKR protocol, we only need to think about the overhead complexity while maintaining zero knowledge for GKR protocol. For every layer of the circuit $C$, the prover samples $R_i(X, Y)$, runs the zeor knowledge sumcheck protocol for at most $3s_i$ variables with individual degree at most $2$ and run the zero knowledge oracle(ZK VPD) for $R(X, Y)$ on $2$ random points. The total complexity is $\mathcal{O}(s_i)$ since the size of $R_i(X, Y)$ is only constant. Suppose the depth of the circuit $C$ is $d$ and the maximum number of gates in one layer is $S$. The total complexity is $\mathcal{O}(d \log S)$. In addition, at the end of the protocol, the prover needs to run the zero knowledge oracle(ZK VPD) for $\dot{V}_d$ on $2$ random points. It needs $\mathcal{O}(S)$. So the total complexity is $\mathcal{O}(S \times d)$, which is linear of the circuit size and it is optimal as the prover must evaluate the circuit $C$. 

\subsection{Zero knowledge VPD}\label{sec::zkvpd}
In this section, we explain how to exemplify the oracles using the zero knowledge VPD protocol. In the preliminary, we have defined the general zero knowledge VPD. We could use it as an oracle to verify any polynomial evaluations. However, at the end of our zero knowledge GKR protocol, for the input layer, the verifier needs to verify $\tilde{V}_d(r) + Z(r)\sum\limits_{c \in \{0, 1\}}R_d(r_1, c)$ and $\tilde{V}_d(s) + Z(s)\sum\limits_{c \in \{0, 1\}}R_d(s_1, c)$, which are not multi-linear polynomials. Here we show that we only need to add several extra terms in the public key of the original zero-knowledge VPD for multi-linear polynomials proposed in~\cite{zkvpd}. The overhead for commit, prove and verification are also minimal.

\medskip\noindent\textbf{Protocol.}
Let $\mathbb{F}$ be a prime-order finite field, $l$ be a variable parameter, and $d$ be a variable-degree parameter such that $\mathcal{O}(1)$ is polynomial in $\lambda$. For our problem, $l = s_n$ and $d = 1$.
\begin{enumerate}
\item \textbf{KeyGen($1^{\lambda}, l, d$):} Select $\alpha, \beta, t_1, t_2, \cdots, t_l, t_{l+1} \in \mathbb{F}$ uniformaly at random, run $bp \leftarrow \text{BilGen}(1^{\lambda})$ and compute $\mathbb{P} = \{g^{\Pi_{i \in W}t_i}, g^{\alpha \Pi_{i \in W}t_i}\}_{W \in \mathcal{W}_{l, d}} \cup \{g^{t_1}\}$. The public parameters are set to be $pp = (bp, \mathbb{P}, g^{\alpha}, g^{\beta}, g^{t_{l+1}}, g^{\alpha t_{l+1}}, g^{\beta t_{l+1}})$ and the verifier parameters are set to be $vp = (bp, g^{t_1}, g^{t_2}, \cdots, g^{t_{l+1}}, g^{\alpha}, g^{\beta})$.

\item \textbf{CommitPoly($\tilde{V}_d, p_1, pp$):} Compute $c_1 = g^{V_d(t_1, t_2, \cdots, t_l) + p_1t_{l+1}}$ and $c_2 = g^{\alpha(V_d(t_1, t_2, \cdots, t_l)+ p_1t_{l+1})}$, output the commitment $com_{R_d} = (c_1, c_2)$.

\item \textbf{CommitPoly($R_d, p_2, pp$):} Compute $c_3 = g^{R_d(t_1) + p_2t_{l+1}}$ and $c_4 = g^{\alpha(R_d(t_1)+ p_2t_{l+1})}$, output the commitment $com_{V_d} = (c_3, c_4)$.

\item \textbf{CommitPoly($\tilde{V}_d + Z(r)R_d, p_1 + Z(r)p_2, pp$):} Compute $c_5 = c_1 \cdot c_3^{Z(r)}$ and $c_6 = c_2 \cdot c_4^{Z(r)}$, output the commitment $com_{\tilde{V}_d + Z(r)R_d} = (c_5, c_6)$.

\item \textbf{CheckCom($com_{\tilde{V}_d}, com_{R_d}, com_{\tilde{V}_d + Z(r)R_d}$, vp):} Output accept if $e(com_{\tilde{V}_d, 1}, g^\alpha) = e(com_{\tilde{V}_d, 2}, g)$and $e(com_{R_d, 1}, g^\alpha) = e(com_{R_d, 2}, g)$ and $e(com_{\tilde{V}_d + Z(r)R_d, 1}, g^\alpha) = e(com_{\tilde{V}_d + Z(r)R_d, 2}, g)$, reject otherwise.

\item \textbf{CommitValue($\tilde{V}_d + Z(r)R_d, r, \tilde{V}_d(r) + Z(r)R_d(r_1), p_1 + Z(r)p_2, p_3, pp$):} the same as the \text{CommitValue} function in general ZK VPD protocol. 
\item \textbf{Ver($com_{V_d + Z(r)R_d}, r, com_{\tilde{V}_d(r) + Z(r)R_d(r_1)}, \pi, vp$):} the same as the \text{Ver} function in general ZK VPD protocol. 
\end{enumerate} 

Notice the verifier could verify the value of $\tilde{V}_d(r) + Z(r)R_d(r_1)$ and $\tilde{V}_d(s) + Z(s)R_d(s_1)$ using this protocol and it is still zero knowledge since the general ZK VPD protocol is zero knowledge. 

For the masking polynomials $G(x)$ and $R_i(x,y)$ in each layer, we use the original zero-knowledge VPD. As the masking polynomials are small, it is not hard to see that the public parameters used in those zk-VPDs are subsets of the public key presented above. The commitment time, prover time, proof size and verification time of each instance are all $O(s_i)$, logarithmic on the number of gates in each layer. 









