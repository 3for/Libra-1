%!TEX root = fastZKP.tex
\section{Introduction}\label{sec:intro}


Zero-knowledge proofs (ZKP) are cryptographic protocols between two parties, a \emph{prover} and a \emph{verifier}, in which the prover can convince the verifier about the validity of a statement without leaking any extra information beyond the fact that the statement is true.  Since they were first introduced by Goldwasser et al.~\cite{goldwasser1989knowledge}, ZKP protocols have evolved from pure theoretical constructs to practical implementations, achieving proof sizes  of just hundreds of bytes and verification times of several milliseconds, regardless of the size of the statement being proved. Due to this successful transition to practice, ZKP protocols have found numerous applications not only in the traditional computation delegation setting but most importantly in providing privacy of transactions in deployed cryptocurrencies (e.g., Zcash~\cite{zerocash}) as well as in other blockchain research projects (e.g., Hawk~\cite{kosba2016hawk}). 




 




 




Despite all progress in practical implementations, ZKP protocols are notoriously hard to scale for large statements, due to a particularly high overhead on generating the proof. For most systems, this is primarily because the prover has to  perform a large number of cryptographic operations, such as exponentiations in an elliptic curve group. And to make things worse the asymptotic complexity of computing the proof is typically more than linear, e.g., $O(C\log C)$ or even $O(C\log^2 C)$, where $C$ is the size of the statement.

Unfortunately, as of today we are yet to construct a ZKP system whose prover time is \emph{optimal}, i.e., linear in the size of the statement $C$ (this is irrespective of whether the ZKP system has per-statement trusted setup, one-time trusted setup or no trusted setup at all). The only notable exception is the recent work by B{\"u}nz et al.~\cite{bulletproofs} that however suffers from linear verification time. Therefore designing ZKP systems that enjoy linear prover time as well as succinct\footnote{In ZKP literature, ``succinct" refers to polylologarithmic in the size of the statement $C$.} proof size and verification time is an open problem, whose resolution can also have significant practical implications. 



\paragraph{Our contributions.} In this paper we propose the first ZKP protocol with linear prover time and succinct proof size and verification time\footnote{aaa} (in the size of the arithmetic circuit representing the statement $C$). Our protocol works  for log-space uniform circuits~\cite{GKR}, a class of circuits that represent most real world applications\footnote{We note here that log-space uniform circuits are required for our verifier to be succinct. If we do not care about succinct verification but only linear prover time, our ZKP protocol can work with arbitrary circuits. }. \yupeng{This claim is too weak. I think we should put the footnote in the previous sentence.} Our scheme is based on the doubly efficient interactive proof proposed by Goldwasser et al. in~\cite{GKR} (referred as GKR protocol in this paper), and the verifiable polynomial delegation scheme proposed by Zhang et al. in~\cite{zhang2017vsql}. As such it comes with \emph{one-time trusted} setup (and not per-statement trusted setup) that depends only on the size of the input (witness) to the statement that is being proved. Our technical  contributions are:
\begin{itemize}
	\item \textbf{GKR with linear prover time.} We develop a new linear-time algorithm to generate the proof in the GKR protocol for (layered) arithmetic circuits. Our algorithm does not require any pattern in the circuit and our result subsumes all existing improvements on the GKR prover assuming special circuit structures, such as regular circuits in~\cite{t13}, data parallel circuits in~\cite{t13,wahby2017full}, circuits with different sub-copies in~\cite{vram}. See related work for more details. 
	\item \textbf{Adding zero-knowledge.} We propose an approach to turn our linear-time argument system into zero-knowledge efficiently. In particular, we show a way to mask the responses of the prover with small random polynomials such that the zero-knowledge variant of the protocol introduces minimal overhead on the verification time compared to the original (unmasked) construction. 
	\item \textbf{Implementation and evaluation.}  We implement our proposed ZKP system, \name, based on our new protocol. \name takes an arithmetic circuit with various types of gates (fan-in 2 and degree $\le 2$, such as $+,-,\times$, AND, XOR, etc.) and compiles it into a ZKP protocol. We conduct thorough comparisons to all existing ZKP systems and show that \name is (one of) the best in all measurements: prover time, prover memory, proof size and verification time. We plan to release our system as an open-source implementation.

\end{itemize}

\subsection{Comparing to other ZKP systems} Table~\ref{tab:zkpall} shows a detailed comparison between \name and existing ZKP systems. As one can see from the complexity, \name is the only system with linear prover time and logarithmic verification time, when the circuit is log-space uniform. Log-space uniform circuits can express a large class of computations. In particular, as it is shown in~\cite{libsnark,vram,libstark}  random access machine computations can be reduced to log-space uniform circuits. The only other system with linear prover time is Bulletproofs~\cite{bulletproofs}. However, the verification of Bulletproofs is linear, \emph{even for log-space uniform circuits}. In the practical front, Bulletproof prover time and verification time are high, as it requires several cryptographic operations for every gate of the circuit.

The proof size and verification time of \name are also competitive to other systems. In asymptotic terms, our proof size is only larger than SNARK and Bulletproof, and verification is slower than SNARK and STARK. Comparing to Hyrax, which is based on the same technique of GKR and VPD, \name improves the performance in all aspects. One can refer to Section~\ref{sec:eval} for our experimental settings and more detailed comparisons. 
 
Finally, among all the systems, SNARK requires a trusted setup phase for every circuit, and \name requires a one-time trusted setup for an upper bound on the input size. See Section~\ref{subsec::discuss} for a discussion on removing the trusted setup in \name. 




\begin{table}[h]
	\centering
	{\fontsize{8}{8}
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
		
		\hline
		&SNARK&Ligero&Bulletproof&Hyrax&STARK&Aurora&\name\\
		\hline
		\hline
		$\mathcal{G}$&$O(C)$&\multicolumn{5}{c|}{NA}&$O(n)$\\
		\hline
		$\P$&$O(C\log^2C)$&$O(C\log C)$&$O(C)$&$O(C\log C)$&$O(C\log^2 C)$&$O(C\log C)$ &$O(C)$\\
		\hline
		$\V$&$O(1)$&$O(C\log C)$&$O(C)$&$O(\sqrt{n}+d\log C)$&$O(\log^2 C)$&$O(C\log C)$&$O(d\log C)$\\
		\hline
		$|\pi|$&$O(1)$&$O(\sqrt{C})$&$O(\log C)$&$O(\sqrt{n}+d\log C)$&$O(\log^2 C)$& $O(\log^2 C)$&$O(d\log C)$\\
		\hline
		\hline
		$\mathcal{G}$&500s&\multicolumn{5}{c|}{NA}&210s\\
		\hline
		$\P$&360s&400s&13,000s&1,041s&30,000s&3199s&201s\\
		\hline
			$\V$&0.003s&4s&900s&9.9s&0.02s&15.2s&0.71s\\
		\hline
		$|\pi|$&0.28KB&1,500KB&5.5KB&185KB&728KB&174.3KB&51KB\\
		\hline
	\end{tabular}
}

\caption{Comparisons to existing ZKP systems. $C$ is the size of the log-space uniform circuit with depth $d$, and $n$ is the size of the input. The numbers are for a circuit computing the root of a Merkle tree with 256 leaves (511 instances of SHA256). The verification time of Hyrax, STARK and \name is also linear to the description of the circuit. In the worst case, the description is $O(C)$.\protect\footnotemark}\label{tab:zkpall}

\end{table}
\footnotetext{STARK is in the random access machine (RAM) model. To compare the performance, we can convert a circuit of size $C$ to a RAM program with $T=\Theta(C)$ steps. }

\subsection{Our Techniques}
Our main technical contributions are a GKR protocol with linear prover time and an efficient approach to turn the GKR protocol into zero knowledge. We summarize the key ideas behind these two contributions. The detailed protocols are presented in Section~\ref{sec::gkrlin} and~\ref{sec:zkp} respectively.

\paragraph{GKR with linear prover.} In~\cite{GKR}, Goldwasser et al. showed an approach to model the evaluation of a layered circuit as a sequence of summations on polynomials defined by values in consecutive layers of the circuit. Using the famous sumcheck protocol (see Section~\ref{subsec::sumcheck}), they developed the GKR protocol allowing the verifier to validate the circuit evaluation in logarithmic time with a logarithmic size proof. However, the polynomials in the protocol are multivariate with $2s$ variables, where $S$ is the number of gates in one layer of the circuit and $s = \log S$. Naively running the sumcheck protocol on these polynomials incurs $S^2$ prover time, as there are at least $2^{2s}=S^2$ monomials in a $2s$-variate polynomial. Later, Cormode et al.~\cite{CMT} observed that these polynomials are sparse, containing only $S$ nonzero monomials and improved the prover time to $S\log S$.

In our new approach, we divide the protocol into two separate sumchecks. In each sumcheck, the polynomial only contains $s$ variables, and can be expressed as the product of two multilinear polynomials. Utilizing the sparsity of the circuit, we develop new algorithms to scan through each gate of the circuit and compute the close form of all these multilinear polynomials explicitly, which takes $O(S)$ time. With this new way of representation, the prover can deploy a dynamic programming technique to generate the proofs in each sumcheck in $O(S)$ time, resulting in a total prover time of $O(S)$. 

\paragraph{Efficient zero knowledge GKR.} The original GKR protocol is not zero knowledge, as the messages in the proof can be viewed as weighed sums of the values in the circuit and leak information. In~\cite{zkvpd,hyrax}, the authors proposed to turn the GKR protocol into zero knowledge by hiding the messages in homomorphic commitments, which incurs a big overhead on the verification time. In~\cite{zksumcheck}, Chiesa et al. proposed an alternative approach by masking the protocol with random polynomials. However, the masking polynomials are as big as the original ones and the prover time becomes exponential, making the approach mainly of theoretical interest. 

In our scheme, we first show that in order to make the sumcheck protocol zero knowledge, the prover can mask it with a "small" polynomial. In particular, the masking polynomial only contains logarithmically many random coefficients. The intuition is that though the original polynomial has $O(2^\ell)$ or more terms ($\ell$ is the number of variables in the polynomial), the prover only sends $O(\ell)$ messages in the sumcheck protocol. Therefore, it suffices to mask the original polynomial with a random one with $O(\ell)$ coefficients to achieve zero knowledge. In particular, we set the masking polynomial as the sum of $\ell$ univariate random polynomials with the same variable-degree. In Section~\ref{subsec:zksumcheck}, we show that the entropy of this mask exactly counters the leakage of the sumcheck, proving that it is efficient and optimal.

Besides the sumcheck, the GKR protocol additional leaks two evaluations of the polynomial defined by values in each layer of the circuit. To make these evaluations zero knowledge, we mask the polynomial by a special low-degree random polynomial. In particular, we show that after the mask, the verifier in total learns 4 messages related to the evaluations of the masking polynomial and we can prove zero knowledge by making these messages linearly independent. Therefore, the masking polynomial is of constant size: it consists of 2 variables with variable degree 2.


\subsection{Related Work}\label{subsec::related}

 In recent years there has been significant progress in efficient zero knowledge proof protocols and systems. In this section, we discuss related work in this area, with the focus on those with sublinear proofs. 

\paragraph{SNARK.} With earlier work of Ishai~\cite{IshaiKO07}, Groth~\cite{Groth10} and Lipmaa~\cite{lipmaa2012progression}, Gennaro et al.~\cite{GGPR13} introduced quadratic arithmetic programs (QAP), which forms the basis of most recent zkSNARK implementations~\cite{parno2013pinocchio,ben2013snarks,braun13,libsnark,ben2014scalable,geppetto,DBLP:conf/eurocrypt/ChiesaTV15,wahby2015efficient,Fiore16,wu2018dizk}. The proof size in SNARKs is constant, and the verification time only depends on the input size, which are particularly appealing for applications such as blockchain and lead to real world products like ZCash~\cite{zerocash}. However, SNARKs usually introduce a high overhead on the prover running time and memory consumption, making it hard to scale to proving large functions. In addition, it relies on a separate trusted setup for every different circuit. 

\paragraph{STARK.} Following the seminal work of Kilian~\cite{Kilian92} and Micali~\cite{Micali00}, Ben-Sasson et al.~\cite{libstark} built a zero knowledge transparent argument of knowledge (zkSTARK) using short probabilistically checkable proof (PCP), which does not rely on trusted setup. STARK executes on the random access machine (RAM) model, and its verification time is only linear to the description of the RAM program, and succinct (logarithmic) on the time of the program.  However, due to the heavy machinery of PCPs, the prover time and memory usage is big in practice (see~\cite{hyrax} and Section~\ref{sec:eval}). 

\paragraph{IOP.} Based on "secure multi-party computations (MPC)-in-the-head" introduced in~\cite{ishai2007zero,giacomelli2016zkboo,chase2017post}, Ames et al.~\cite{ligero} proposed a zero knowledge proof scheme called Ligero. It only uses symmetric key operations and the prover time is fast in practice. However, it generates proofs of size $O(\sqrt{C})$, which is several megabytes in practice for moderate size circuits. In addition, the verification time is quasi-linear to the size of the circuit. Both of these drawbacks make it hard to be applied to applications like blockchain. It is categorized as interactive PCPs, which is a special case of interactive oracle proofs (IOPs). Recently, Ben-Sasson et al. proposed a new zero knowledge scheme in the IOP model named Aurora, which improves the proof size to $\log^2 C$.   

\paragraph{Discrete log.} Building on the work of Groth~\cite{groth2009linear}, Bayer and Groth~\cite{bayer2012efficient} and Bootle et al.~\cite{bootle2016efficient,bootle2017linear}, B{\"u}nz et al.~\cite{bulletproofs} proposed Bulletproof, a zero knowledge arguments based on discrete logarithm assumptions. To the best of our knowledge, this is the only line of work that achieves a linear prover time. The proof size in Bulletproof is $O(\log C)$, and is small in practices (several KBs). However, both the prover and the verification involve several cryptographic operations per gate of the circuit, which limits the size it can handle.

\paragraph{Interactive proof.} The line of work that relates to our paper the most is based on interactive proofs~\cite{goldwasser1989knowledge}. In the seminal work of~\cite{GKR}, Goldwasser et al. proposed a doubly efficient interactive proof for layered arithmetic circuits. Later, Cormode et al.~\cite{CMT} improves the prover complexity of the interactive proof in~\cite{GKR} to $O(C\log C)$ using multilinear extensions instead of low degree extensions. Several follow-up work further reduces the prover time assuming special structures of the circuit. For regular circuits where the wiring pattern can be described in constant space and time, Thaler~\cite{t13} introduced a protocol with $O(C)$ prover time; for data parallel circuits with many copies of small circuits with size $C'$, a $O(C\log C')$ protocol is presented in the same work, later improved to $O(C+C'\log C)$ by Wahby et al. in~\cite{wahby2017full}; for circuits with many non-connected but different copies, Zhang et al. showed a protocol with $O(C\log C')$ prover time. Our result of a protocol with $O(C)$ prover time for arbitrary layered circuits subsumes all of these protocols. 

In~\cite{zhang2017vsql}, Zhang et al. extended the doubly efficient interactive proofs to argument systems using verifiable polynomial delegations. Zhang et al.~\cite{vram} and Wahby et al.~\cite{hyrax} make the argument system zero knowledge by putting all the messages in the proof into homomorphic commitments, as proposed by Cramer and Damgard in~\cite{cramer1998zero}. This approach introduces a high overhead on the verification time compared to the plain argument system without zero knowledge, as each addition becomes a multiplication and each multiplication becomes an exponentiation in the homomorphic commitments. The multiplicative overhead is around two orders of magnitude in practice. Additionally, the scheme of~\cite{hyrax}, Hyrax, removes the trusted setup of the argument scheme by introducing a new polynomial delegation, increasing the proof size and verification time to $O(\sqrt{n})$ where $n$ is the input size of the circuit. 

\paragraph{Lattice-based.} Recently Baum et al.~\cite{baum2018sub} proposed the first lattice-based zero knowledge argument with sublinear proof size. It opens the interesting direction of exploring efficient implementations of lattice-based zero knowledge proofs.