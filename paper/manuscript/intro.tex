\section{Introduction}\label{sec:intro}


Zero knowledge proof (ZKP) allows a prover to convince a verifier of a statement without leaking any extra information beyond the validity of the statement. Since it was first introduced by Goldwasser et al. in~\cite{goldwasser1989knowledge}, zero knowledge proof has found varies applications both in the classical server-client setting for authentications and signatures, and in emerging techniques like such as blockchains.

In recent years, there has been great effort towards realizing zero knowledge proof systems efficiently in practice. A big breakthrough comes with the work of Gennaro et al.~\cite{GGPR13}, leading to many ZKP systems categorized as succinct non-interactive knowledge of argument (SNARK). In SNARK, the proof size is only hundreds of bytes and the verification time is several milliseconds regardless of the size of the statement, making it particularly useful in the blockchain setting. This leads to real world products of privacy-preserving crypto-currencies like Zcash~\cite{zerocash}, and research prototypes of privacy-preserving smart contract such as Hawk~\cite{kosba2016hawk}.

Despite of the great success of SNARK and zero knowledge proof in general, they are known to be hard to scale to large statements, as they usually introduce a high overhead on the prover side in order to generate the proof. There are several new constructions of ZKP system trying to improve the prover overhead and remove the per-statement trusted setup required in SNARKs, but most of them increase the verification time to be linear to the size of the statement, which is not desirable in many applications of zero knowledge proofs including the blockchains. See Section~\ref{subsec::related} for an overview of existing ZKP systems. This urges the need of designing zero knowledge proofs with succinct proof size, verification time and small overhead on the prover time.



\paragraph{Our contributions.} Towards the goal above, in this paper, we propose the first zero knowledge scheme with prover time linear to the size of the arithmetic circuit representing the statement, and has succinct proof and verification for a large class of computations. Our scheme is based on the doubly efficient interactive proof proposed by Goldwasser et al. in~\cite{GKR} (referred as \emph{GKR} protocol in this paper), and the verifiable polynomial delegation scheme proposed by Zhang et al. in~\cite{zhang2017vsql}. Our main contributions are:
\begin{itemize}
	\item \textbf{GKR with linear prover time.} \babis{somehow you need to make a big deal here about the sublinear verification}We develop a new algorithm to generate the proof in the GKR protocol for arbitrary layered arithmetic circuit in linear time. Our prover time is asymptotically the same as evaluating the circuit and is optimal. Our algorithm does not require any pattern in the circuit and this result subsumes all existing improvements on the GKR prover assuming special circuit structures, such as regular circuits in~\cite{t13}, data parallel circuits in~\cite{t13,wahby2017full}, circuits with different sub-copies in~\cite{vram}. See related work for more details. 
	\item \textbf{Efficient zero knowledge proof protocol.} We propose an approach to turn the argument system based on GKR and VPD to zero knowledge efficiently. In particular, we show a way to mask the protocols with small random polynomials such that the zero knowledge variant of the protocol introduces minimal overhead on the verification time compared to the original scheme. 
	\item \textbf{Implementation and evaluations.} \babis{describe more the kind of circuit, layered?} We implement a zero knowledge proof system, \name, based on our new protocol. \name takes an arithmetic circuit with varies types of gates (fan-in 2 and degree $\le 2$, such as $+,-,\times$, AND, XOR, etc.) and compiles it into a zero knowledge proof protocol. We conduct thorough comparisons to all existing zero knowledge proof systems and show that \name is (one of) the best in all measurements: prover time, prover memory, proof size and verification time. We plan to release our system as an open-source tool.

\end{itemize}

\paragraph{Comparing to other ZKP systems.} Table~\ref{tab:zkpall} shows the highlight of the comparisons between \name and existing ZKP systems. As one can see from the complexity, \name is the system with linear prover time and logarithmic verification time if the circuit is log-space uniform. This captures a large class of computations, as it is shown in~\cite{libsnark,vram,libstark} that random access machine computations can be reduced to log-space uniform circuits. The only other system with linear prover time is Bulletproof. However, in practice the prover time and the verification time of Bulletproof are high, as it requires several cryptographic operations for every gate of the circuit.

The proof size and verification time of \name are also competitive to other systems. Our proof size is only larger than SNARK and Bulletproof, and verification is slower than SNARK and STARK. Comparing to Hyrax, which is based on the same technique of GKR and VPD, \name improves the performance in all aspects. One can refer to Section~\ref{sec:eval} for our experimental settings and more detailed comparisons. 
 
Finally, among all the systems, SNARK requires a trusted setup phase for every circuit, and \name requires a one-time trusted setup for an upper bound on the input size. See Section~\ref{subsec::discuss} for a discussion on removing the trusted setup in \name. 




\begin{table}[h]
	\centering
	{\footnotesize
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
		
		\hline
		&SNARK&Ligero&Bulletproof&Hyrax&STARK&Aurora&\name\\
		\hline
		\hline
		Setup&$O(C)$&\multicolumn{5}{c|}{NA}&$O(n)$\\
		\hline
		Prover&$O(C\log^2C)$&$O(C\log C)$&$O(C)$&$O(C\log C)$&$O(C\log^2 C)$&$O(C\log C)$ &$O(C)$\\
		\hline
		Verifier&$O(1)$&$O(C\log C)$&$O(C)$&$O(\sqrt{n}+d\log C)$&$O(\log^2 C)$&$O(C\log C)$&$O(d\log C)$\\
		\hline
		Proof&$O(1)$&$O(\sqrt{C})$&$O(\log C)$&$O(\sqrt{n}+d\log C)$&$O(\log^2 C)$& $O(\log^2 C)$&$O(d\log C)$\\
		\hline
		\hline
		Setup&500s&\multicolumn{5}{c|}{NA}&210s\\
		\hline
		Prover&360s&400s&13,000s&1,041s&30,000s&600s&504s\\
		\hline
		Verifier&0.003s&4s&900s&9.9s&0.02s&1.5s&1.07s\\
		\hline
		Proof&0.28KB&1,500KB&5.5KB&185KB&500KB&120KB&51KB\\
		\hline
	\end{tabular}
}

\caption{\babis{What is $n$? Also, I believe that Name does not work for arbitrary circuits whereas others do. BE VERY DETAILED ABOUT THE TYPE OF CIRCUITS THaT name supports}Comparisons to existing zero knowledge proof systems. $C$ is the size of the circuit with depth $d$, and $n$ is the size of the input. The numbers are for a circuit computing the root of a Merkle tree with 256 leaves (511 instances of SHA256). The verification time of Hyrax, STARK and \name is also linear to a description of the circuit. In the worst case, the description is $O(C)$.\protect\footnotemark}\label{tab:zkpall}

\end{table}
\footnotetext{STARK is in the random access machine (RAM) model. To compare the performance, we can convert a circuit of size $C$ to a RAM program with $T=\Theta(C)$ steps. }

\subsection{Our Techniques}
Our main technical contributions are a GKR protocol with linear prover time and an efficient approach to turn the GKR protocol into zero knowledge. We summarize the key ideas behind these two contributions. The detailed protocols are presented in Section~\ref{sec::gkrlin} and~\ref{sec:zkp} respectively.

\paragraph{GKR with linear prover.} In~\cite{GKR}, Goldwasser et al. showed an approach to model the evaluation of a layered circuit as a sequence of summations on polynomials defined by values in consecutive layers of the circuit. Using the famous sumcheck protocol (see Section~\ref{subsec::sumcheck}), they developed the GKR protocol allowing the verifier to validate the circuit evaluation in logarithmic time with a logarithmic size proof. However, the polynomials in the protocol are multivariate with $2s$ variables, where $S$ is the number of gates in one layer of the circuit and $s = \log S$. Naively running the sumcheck protocol on these polynomials incurs $S^2$ prover time, as there are at least $2^{2s}=S^2$ monomials in a $2s$-variate polynomial. Later, Cormode et al.~\cite{CMT} observed that these polynomials are sparse, containing only $S$ nonzero monomials and improved the prover time to $S\log S$.

In our new approach, we divide the protocol into two separate sumchecks. In each sumcheck, the polynomial only contains $s$ variables, and can be expressed as the product of two multilinear polynomials. Utilizing the sparsity of the circuit, we develop new algorithms to scan through each gate of the circuit and compute the close form of all these multilinear polynomials explicitly, which takes $O(S)$ time. With this new way of representation, the prover can deploy a dynamic programming technique to generate the proofs in each sumcheck in $O(S)$ time, resulting in a total prover time of $O(S)$. 

\paragraph{Efficient zero knowledge GKR.} The original GKR protocol is not zero knowledge, as the messages in the proof can be viewed as weighed sums of the values in the circuit and leak information. In~\cite{zkvpd,hyrax}, the authors proposed to turn the GKR protocol into zero knowledge by hiding the messages in homomorphic commitments, which incurs a big overhead on the verification time. In~\cite{zksumcheck}, Chiesa et al. proposed an alternative approach by masking the protocol with random polynomials. However, the masking polynomials are as big as the original ones and the prover time becomes exponential, making the approach mainly of theoretical interest. 

In our scheme, we first show that in order to make the sumcheck protocol zero knowledge, the prover can mask it with a "small" polynomial. In particular, the masking polynomial only contains logarithmically many random coefficients. The intuition is that though the original polynomial has $O(2^\ell)$ or more terms ($\ell$ is the number of variables in the polynomial), the prover only sends $O(\ell)$ messages in the sumcheck protocol. Therefore, it suffices to mask the original polynomial with a random one with $O(\ell)$ coefficients to achieve zero knowledge. In particular, we set the masking polynomial as the sum of $\ell$ univariate random polynomials with the same variable-degree. In Section~\ref{subsec:zksumcheck}, we show that the entropy of this mask exactly counters the leakage of the sumcheck, proving that it is efficient and optimal.

Besides the sumcheck, the GKR protocol additional leaks two evaluations of the polynomial defined by values in each layer of the circuit. To make these evaluations zero knowledge, we mask the polynomial by a special low-degree random polynomial. In particular, we show that after the mask, the verifier in total learns 4 messages related to the evaluations of the masking polynomial and we can prove zero knowledge by making these messages linearly independent. Therefore, the masking polynomial is of constant size: it consists of 2 variables with variable degree 2.


\subsection{Related Work}\label{subsec::related}

 In recent years there has been significant progress in efficient zero knowledge proof protocols and systems. In this section, we discuss related work in this area, with the focus on those with sublinear proofs. 

\paragraph{SNARK.} With earlier work of Ishai~\cite{IshaiKO07}, Groth~\cite{Groth10} and Lipmaa~\cite{lipmaa2012progression}, Gennaro et al.~\cite{GGPR13} introduced quadratic arithmetic programs (QAP), which forms the basis of most recent zkSNARK implementations~\cite{parno2013pinocchio,ben2013snarks,braun13,libsnark,ben2014scalable,geppetto,DBLP:conf/eurocrypt/ChiesaTV15,wahby2015efficient,Fiore16,wu2018dizk}. The proof size in SNARKs is constant, and the verification time only depends on the input size, which are particularly appealing for applications such as blockchain and lead to real world products like ZCash~\cite{zerocash}. However, SNARKs usually introduce a high overhead on the prover running time and memory consumption, making it hard to scale to proving large functions. In addition, it relies on a separate trusted setup for every different circuit. 

\paragraph{STARK.} Following the seminal work of Kilian~\cite{Kilian92} and Micali~\cite{Micali00}, Ben-Sasson et al.~\cite{libstark} built a zero knowledge transparent argument of knowledge (zkSTARK) using short probabilistically checkable proof (PCP), which does not rely on trusted setup. STARK executes on the random access machine (RAM) model, and its verification time is only linear to the description of the RAM program, and succinct (logarithmic) on the time of the program.  However, due to the heavy machinery of PCPs, the prover time and memory usage is big in practice (see~\cite{hyrax} and Section~\ref{sec:eval}). 

\paragraph{IOP.} Based on "secure multi-party computations (MPC)-in-the-head" introduced in~\cite{ishai2007zero,giacomelli2016zkboo,chase2017post}, Ames et al.~\cite{ligero} proposed a zero knowledge proof scheme called Ligero. It only uses symmetric key operations and the prover time is fast in practice. However, it generates proofs of size $O(\sqrt{C})$, which is several megabytes in practice for moderate size circuits. In addition, the verification time is quasi-linear to the size of the circuit. Both of these drawbacks make it hard to be applied to applications like blockchain. It is categorized as interactive PCPs, which is a special case of interactive oracle proofs (IOPs). Recently, Ben-Sasson et al. proposed a new zero knowledge scheme in the IOP model named Aurora, which improves the proof size to $\log^2 C$.   

\paragraph{Discrete log.} Building on the work of Groth~\cite{groth2009linear}, Bayer and Groth~\cite{bayer2012efficient} and Bootle et al.~\cite{bootle2016efficient,bootle2017linear}, B{\"u}nz et al.~\cite{bulletproofs} proposed Bulletproof, a zero knowledge arguments based on discrete logarithm assumptions. To the best of our knowledge, this is the only line of work that achieves a linear prover time. The proof size in Bulletproof is $O(\log C)$, and is small in practices (several KBs). However, both the prover and the verification involve several cryptographic operations per gate of the circuit, which limits the size it can handle.

\paragraph{Interactive proof.} The line of work that relates to our paper the most is based on interactive proofs~\cite{goldwasser1989knowledge}. In the seminal work of~\cite{GKR}, Goldwasser et al. proposed a doubly efficient interactive proof for layered arithmetic circuits. Later, Cormode et al.~\cite{CMT} improves the prover complexity of the interactive proof in~\cite{GKR} to $O(C\log C)$ using multilinear extensions instead of low degree extensions. Several follow-up work further reduces the prover time assuming special structures of the circuit. For regular circuits where the wiring pattern can be described in constant space and time, Thaler~\cite{t13} introduced a protocol with $O(C)$ prover time; for data parallel circuits with many copies of small circuits with size $C'$, a $O(C\log C')$ protocol is presented in the same work, later improved to $O(C+C'\log C)$ by Wahby et al. in~\cite{wahby2017full}; for circuits with many non-connected but different copies, Zhang et al. showed a protocol with $O(C\log C')$ prover time. Our result of a protocol with $O(C)$ prover time for arbitrary layered circuits subsumes all of these protocols. 

In~\cite{zhang2017vsql}, Zhang et al. extended the doubly efficient interactive proofs to argument systems using verifiable polynomial delegations. Zhang et al.~\cite{vram} and Wahby et al.~\cite{hyrax} make the argument system zero knowledge by putting all the messages in the proof into homomorphic commitments, as proposed by Cramer and Damgard in~\cite{cramer1998zero}. This approach introduces a high overhead on the verification time compared to the plain argument system without zero knowledge, as each addition becomes a multiplication and each multiplication becomes an exponentiation in the homomorphic commitments. The multiplicative overhead is around two orders of magnitude in practice. Additionally, the scheme of~\cite{hyrax}, Hyrax, removes the trusted setup of the argument scheme by introducing a new polynomial delegation, increasing the proof size and verification time to $O(\sqrt{n})$ where $n$ is the input size of the circuit. 

\paragraph{Lattice-based.} Recently Baum et al.~\cite{baum2018sub} proposed the first lattice-based zero knowledge argument with sublinear proof size. It opens the interesting direction of exploring efficient implementations of lattice-based zero knowledge proofs.