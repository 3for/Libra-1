%!TEX root = fastZKP.tex
\section{Preliminary}
\label{sec::prelim}
In this section, we will introduce some useful results and definitions.
\subsection{Interactive Proof}
Traditional proof involves two static objects: a prover $\mathcal{P}$ and a verifier $\mathcal{V}$. The prover $\mathcal{P}$ takes a statement $x$ as input and generate a string $\pi$ as proof, then the verifier $\mathcal{V}$ checks if the statement $x$ and the proof $\pi$ are correct. An interactive proof is a stronger notion of proof, it allows the prover $\mathcal{P}$ to convince the verifier $\mathcal{V}$ of the validity of some statement. The interactive proof runs in several rounds, allowing the verifier to ask questions in each round based on prover's answers of previous rounds. We phrase this in terms of $\mathcal{P}$ trying to convince $\mathcal{V}$ that $f(x)=1$. The proof system is interesting if and only if the running time of $\mathcal{V}$ is less than the time of directly computing the function $f$.

We formalize the "interactive proof" in the following:	
\begin{definition}
	Let $f$ be a boolean function. A pair of interactive machines $\langle\mathcal{P}, \mathcal{V}\rangle$ is an interactive proof for $f$ with soundness $\epsilon$ if the following holds:
	\begin{itemize}
		\item {\bf Completeness.} For every $x$ such that $f(x) = 1$ it holds that $\Pr[\langle\mathcal{P}, \mathcal{V}\rangle(x)=accept]=1$.
		\item {\bf $\epsilon$-Soundness.} For any $x$ with $f(x) \neq 1$ and any $\mathcal{P}^*$ it holds that $\Pr[\langle\mathcal{P^*},\mathcal{V}\rangle=accept] \le \epsilon$
	\end{itemize}
\end{definition}

\subsection{Sumcheck Protocol}
\label{subsec::sumcheck}
The sumcheck problem is a fundamental problem that serves as a building block for varies applications. Informally the problem requires us to sum on a binary hypercube $(b_1, b_2, ..., b_{l})$ for a given polynomial $g(x_1, x_2, ..., x_{l})$. Directly compute the function requires exponential computation, Lund et al.\cite{sumcheck} proposed a interactive proof protocol such that a computationally unbounded prover $\mathcal{P}$ can convince a computationally bounded verifier $\mathcal{V}$ that $$H=\sum_{b_1\in\{0,1\}}\sum_{b_2\in\{0,1\}}...\sum_{b_{l}\in\{0,1\}}g(b_1,b_2,...,b_{l})$$
Using this protocol, even a polynomial bounded verifier can verify the statement above. Now we formally define the problem and provide a description of the protocol.

\begin{definition}
	Let $g$ be an $l$-variate polynomial $g(b_1, b_2, ..., b_{l})$ over a field $\mathbb{F}$; the prover's goal is to convince that 

	$$H=\sum_{b_1\in\{0,1\}}\sum_{b_2\in\{0,1\}}...\sum_{b_{l}\in\{0,1\}}g(b_1,b_2,...,b_{l})$$
\end{definition}

\begin{protocol}[\textbf{Sumcheck}]
	The protocol proceeds in $l$ rounds. 
	\begin{itemize}
		\item In the first round, the prover sends a univariate polynomial $$g_1(x_1)\overset{def}{=}\sum_{b_2\in\{0,1\}}...\sum_{b_{l}\in\{0,1\}}g(x_1, b_2, b_3, ..., b_{l})\textnormal{,}$$ the verifier checks $H=g_1(0)+g_1(1)$. Then the verifier sends a random number $r_1$ to prover, and sets $G_1\overset{def}{=}g_{1}(r_1)$.
		\item In the $i$-th round, where $2\le i \le l-1$, the prover sends 
		$$g_{i}(x_{i})\overset{def}{=}\sum_{b_{i+1}\in\{0,1\}}\sum_{b_{i+2}\in\{0,1\}}...\sum_{b_{l}\in\{0,1\}}g(r_1, r_2, ..., r_{i-1}, x_{i}, b_{i+1}, b_{i+2}, ..., b_{l})\textnormal{.}$$ 
		The verifier checks $G_{i-1}=g_{i}(0)+g_{i}(1)$, and then sends a random number $r_{i}$ to prover. The verifier sets $G_{i}\overset{def}{=}g_{i}(r_{i})$.
		\item In the $l$-th round, the prover sends $$g_{l}(x_{l})\overset{def}{=}g(r_1, r_2, ..., r_{l-1}, x_{l})$$, the verifier checks $G_{l-1}=g_{l}(0)+g_{l}(1)$. Then verifier generate a random number $r_{l}$ and sets $G_{l}\overset{def}{=}g_{l}(r_{l})$. Given oracle access to $g$, the verifier will accept the prover if and only if $G_l = g(r_1, r_2, ..., r_l)$. We will provide a implemetation of the oracle latter. 
		%The verifier also compute $Answer\overset{def}{=}g(r_1, r_2, ..., r_{l})$ locally. Verifier will accept iff $G_{l}=Answer$.
	\end{itemize}
\end{protocol}

\begin{definition}[\textbf{Multi-linear Extension}]
	Let $V:\{0, 1\}^l \rightarrow \mathbb{F}$ be a function. A \textit{multi-linear extension} is the unique polynomial $\tilde{V}: \mathbb{F}^l \rightarrow \mathbb{F}$ defined as:
	$$\tilde{V}(x_1, x_2, ..., x_{l})\overset{def}{=}\sum_{b\in\{0,1\}^l}\prod_{i=1}^{l}[((1-x_i)(1-b_i)+x_ib_i) \times V(b)]$$
	where $b_i$ is $i$-th bit of b.

	It's easy to see that $\tilde{V}(x_1, x_2, ..., x_{l}) = V(x_1, x_2, ..., x_{l})$ on boolean hypercube.
\end{definition}

\input{CMT}
\input{zkvpd}
