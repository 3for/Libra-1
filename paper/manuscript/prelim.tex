%!TEX root = fastZKP.tex
\section{Preliminary}
\label{sec::prelim}
In this section, we will introduce some useful results and definitions.
\subsection{Interactive Proof}
Traditional proof involves two static objects: a prover $\mathcal{P}$ and a verifier $\mathcal{V}$. The prover $\mathcal{P}$ takes a statement $x$ as input and generate a string $\pi$ as proof, then the verifier $\mathcal{V}$ checks if the statement $x$ and the proof $\pi$ are correct. An interactive proof is a stronger notion of proof, it allows the prover $\mathcal{P}$ to convince the verifier $\mathcal{V}$ of the validity of some statement. The interactive proof runs in several rounds, allowing the verifier to ask questions in each round based on prover's answers of previous rounds. We phrase this in terms of $\mathcal{P}$ trying to convince $\mathcal{V}$ that $f(x)=1$. The proof system is interesting if and only if the running time of $\mathcal{V}$ is less than the time of directly computing the function $f$.

We formalize the "interactive proof" in the following:	
\begin{definition}
	Let $f$ be a boolean function. A pair of interactive machines $\langle\mathcal{P}, \mathcal{V}\rangle$ is an interactive proof for $f$ with soundness $\epsilon$ if the following holds:
	\begin{itemize}
		\item {\bf Completeness.} For every $x$ such that $f(x) = 1$ it holds that $\Pr[\langle\mathcal{P}, \mathcal{V}\rangle(x)=accept]=1$.
		\item {\bf $\epsilon$-Soundness.} For any $x$ with $f(x) \neq 1$ and any $\mathcal{P}^*$ it holds that $\Pr[\langle\mathcal{P^*},\mathcal{V}\rangle=accept] \le \epsilon$
	\end{itemize}
\end{definition}

\subsection{Sumcheck Protocol}
\label{subsec::sumcheck}
The sumcheck problem is a fundamental problem that serves as a building block for varies applications. The problem is to sum a polynomial $f: \mathbb{F}^\ell \rightarrow \mathbb{F}$ on the binary hypercube $$\sum\limits_{b_1,b_2,\ldots,b_\ell\in\{0,1\}}f(b_1,b_2,...,b_\ell).$$ 
Directly computing the sum requires exponential time in $\ell$, as there are $2^\ell$ combinations of $b_1,\ldots,b_\ell$. Lund et al.~\cite{sumcheck} proposed a \emph{sumcheck} protocol that allows a verifier $\mathcal{V}$ to delegate the computation to a computationally unbounded prover $\mathcal{P}$, who can convince $\mathcal{V}$ that $H$ is the correct sum. We provide a description of the sumcheck protocol.

\begin{protocol}[\textbf{Sumcheck}]
\label{prot::sumcheck}
	The protocol proceeds in $\ell$ rounds. 
	\begin{itemize}
		\item In the first round, the prover sends a univariate polynomial $$f_1(x_1)\overset{def}{=}\sum\limits_{b_2,\ldots,b_\ell\in\{0,1\}}f(x_1,b_2,...,b_\ell)\, ,$$ the verifier checks $H=f_1(0)+f_1(1)$. Then the verifier sends a random challenge $r_1\in\mathbb{F}$ to the prover.
		\item In the $i$-th round, where $2\le i \le l-1$, the prover sends a univariate polynomial
		$$f_{i}(x_{i})\overset{def}{=}\sum\limits_{b_{i+1},\ldots,b_\ell\in\{0,1\}}f(r_1,\ldots, r_{i-1}, x_{i}, b_{i+1},\ldots, b_{\ell})\, ,$$ 
		the verifier checks $f_{i-1}(r_{i-1})=f_{i}(0)+f_{i}(1)$, and sends a random challenge $r_{i}\in\mathbb{F}$ to the prover.
		\item In the $\ell$-th round, the prover sends a univariate polynomial $$f_{\ell}(x_{\ell})\overset{def}{=}f(r_1, r_2, ..., r_{l-1}, x_{\ell})\, ,$$ the verifier checks $f_{\ell-1}(r_{\ell-1})=f_{\ell}(0)+f_{\ell}(1)$. The verifier generates a random challenge $r_{\ell}\in\mathbb{F}$. Given oracle access to an evaluation $f(r_1, r_2, ..., r_\ell)$ of $f$, the verifier will accept if and only if $f_{\ell}(r_\ell) = f(r_1, r_2, ..., r_\ell)$. The instantiation of the oracle access depends on the application of the sumcheck protocol.
	\end{itemize}
\end{protocol}

The proof size of the sumcheck protocol is $O(d\ell)$, where $d$ is the variable-degree of $f$, as in each round, the prover sends a univariate polynomial for each variable in $f$, which can be uniquely defined by $d+1$ points. The verifier time of the protocol is $O(d\ell)$. The prover time depends on the degree and the sparsity of $f$, and we will give the complexity later in our scheme. The sumcheck protocol is complete and sound with $\epsilon = \frac{d\ell}{|\mathbb{F}|}$. 

\begin{definition}[\textbf{Multi-linear Extension}]
	Let $V:\{0, 1\}^l \rightarrow \mathbb{F}$ be a function. The \textit{multi-linear extension} of $V$ is the unique polynomial $\tilde{V}: \mathbb{F}^l \rightarrow \mathbb{F}$ such that $\tilde{V}(x_1, x_2, ..., x_{l}) = V(x_1, x_2, ..., x_{l})$ for all $x_1, x_2, ..., x_{l}\in\{0,1\}^l$.
	
	
	$\tilde{V}$ can be expressed as:
	$$\tilde{V}(x_1, x_2, ..., x_{l})=\sum_{b\in\{0,1\}^l}\prod_{i=1}^{l}[((1-x_i)(1-b_i)+x_ib_i) \times V(b)]$$
	where $b_i$ is $i$-th bit of b.
	
	
\end{definition}

\input{CMT}
\input{zkvpd}
