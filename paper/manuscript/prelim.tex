%!TEX root = fastZKP.tex
\section{Preliminary}
\label{sec::prelim}

\subsection{Notations}

polynomials, PPT, vectors, ,binary, array, security parameter, $\neg$,

\subsection{Cryptographic Assumptions}

\paragraph{Bilinear pairing.} Let $\lambda$ be the security parameter, $\mathbb{G}, \mathbb{G}_T$ be two groups of order $p$ and $g\in\mathbb{G}$ be a generator. $e: \mathbb{G}\times\mathbb{G}\rightarrow\mathbb{G}_T$ denotes a bilinear map and we use $\mathsf{bp}=(p,\mathbb{G},\mathbb{G}_T,e,g)\leftarrow\mathsf{BilGen}(1^\lambda)$ for the generation of parameters for the bilinear map.

Our scheme relies on the following assumptions.

\begin{assumption}[$q$-Strong Diffie-Hellman]
	\label{asp::qSDH}
	For any probabilistic polynomial time (PPT) adversary $\mathcal{A}$, the following holds:
	
	\[\Pr\left[ \begin{aligned}
	&\mathsf{bp} \leftarrow \mathsf{BilGen}(1^\lambda) & \\
	&s \overset{R}{\leftarrow} \mathbb{Z}^{*}_{p} & : (x, e(g, g)^{\frac{1}{s+x}}) \leftarrow \mathcal{A}(1^\lambda, \sigma)\\
	&\sigma = (\mathsf{bp}, g^s, ..., g^{s^q})
	\end{aligned} \right] \le \negl{(\lambda)}\]
\end{assumption}

The second assumption is a generalization of the $q$-PKE assumption~\cite{groth2010short} to multivariate polynomials, proposed in~\cite{zhang2017vsql,zkvpd}. Let $\mathcal {W}_ {\ell,d}$ be the set of all multisets of $\{1, . . . , \ell\}$ with the cardinality of each element being at most $d$. 

\begin{assumption}[$(d,\ell)$-Extended Power Knowledge of Exponent]
	\label{asp::dlEPKE}
	For any PPT adversary $\mathcal{A}$, there is a polynomial time algorithm $\mathcal{E}$ (takes the same randomness of $\mathcal{A}$ as input) such that for all benign auxiliary inputs $z \in \{0,1\}^{\poly({\lambda})}$ the following probability is negligible:
	\[\Pr\left[ \begin{aligned}
	\mathsf{bp} \leftarrow \mathsf{BilGen}(1^\lambda) && \\
	s_1, ..., s_\ell, s_{\ell + 1}, \alpha \overset{R}{\leftarrow} Z_{p}^*, s_0=1 && \\
	\sigma_1 = (\{g^{\prod_{i\in W}s_i}\}_{W\in \mathcal{W}_{\ell, d}, g^{s_{\ell+1}}}) &&\hspace*{10pt} e(h, g^\alpha)=e(\tilde{h}, g)\\
	\sigma_2 = (\{g^{\alpha\prod_{i\in Ws_i}}\}_{W\in \mathcal{W}_{\ell, d}}, g^{\alpha s_{\ell+1}}) && : \prod_{W\in \mathcal{W}_{\ell, d}}g^{a_{W}\prod_{i\in W}s_i}g^{b{s_{\ell+1}}}\neq h\\
	\sigma = (\mathsf{bp}, \sigma_1, \sigma_2, g^{\alpha}) && \\
	\mathbb{G} \times \mathbb{G} \ni (h, \tilde{h}) \leftarrow \mathcal{A} \left(1^{\lambda}, \sigma, z\right)&& \\
	\left( a _ { 0 } , \dots , a _ { \left| \mathcal { W } _ { \ell , d } \right| } , b \right) \leftarrow \mathcal { E } \left( 1 ^ { \lambda } , \sigma , z \right) &&
	\end{aligned}\right] \le \negl{(\lambda)}\]
\end{assumption}

\subsection{Interactive Proof and Zero-knowledge Arguments}

\paragraph{Interactive proof.} An interactive proof allows a prover $\P$ to convince a verifier $\V$ the validity of some statement. The interactive proof runs in several rounds, allowing $\V$ to ask questions in each round based on $\P$'s answers of previous rounds. We phrase this in terms of $\P$ trying to convince $\V$ that $f(x)=1$. The proof system is interesting if and only if the running time of $\V$ is less than the time of directly computing the function $f$.

We formalize the interactive proof in the following:	
\begin{definition}\label{def:ip}
	Let $f$ be a boolean function. A pair of interactive machines $\langle\mathcal{P}, \mathcal{V}\rangle$ is an interactive proof for $f$ with soundness $\epsilon$ if the following holds:
	\begin{itemize}
		\item {\bf Completeness.} For every $x$ such that $f(x) = 1$ it holds that $\Pr[\langle\mathcal{P}, \mathcal{V}\rangle(x)=accept]=1$.
		\item {\bf $\epsilon$-Soundness.} For any $x$ with $f(x) \neq 1$ and any $\mathcal{P}^*$ it holds that $\Pr[\langle\mathcal{P^*},\mathcal{V}\rangle=accept] \le \epsilon$
	\end{itemize}
\end{definition}


\paragraph{Zero-knowledge Argument.} An argument system for an NP relationship $R$ is a protocol between a computationally bounded prover $\P$ and a verifier $\V$. At the end of the protocol, $\V$ is convinced by $\P$ that there exists a witness $w$ such that $(x; w) \in R$ for some input $x$. We focus on arguments of knowledge which have the stronger property that if the prover convinces the verifier of the statementâ€™s validity, then the prover must know $w$. We use $\mathcal{G}$ to represent public key $\pk$ and verification key $\vk$ generation phase. Formally, consider the definition below.

\begin{definition}\label{def::zkp}
	
	Let $R$ be an NP relation and let $\lambda$ be the security parameter. A tuple of algorithm $(\mathcal{G}, \mathcal{P}, \mathcal{V})$ is a zero knowledge argument fro $R$ if the following holds.
	
	\begin{itemize}
		
		\item \textbf{Correctness}. For every $(\pk, \vk)$ output by $\mathcal{G}(1^\lambda)$ and $(x, w) \in R$, 
		$$\langle \P(\pk, w), \V(\vk) \rangle(x) = \accept$$
		
		\item \textbf{Soundness}. For any PPT prover $\P$, there exists a PPT extractor $\varepsilon$ such that for any $x$ it holds that
		
		$$\Pr[\langle\P(\pk), \V(\vk) \rangle(x) = \accept \wedge (x, w) \notin R | w \leftarrow \varepsilon(\pk, x)] \leq \neg(\lambda)$$
		
		\item \textbf{Zero knowledge}. There exists a PPT simulator $\S$ such that for any PPT adversary $\A$, auxiliary input $z \in \{0, 1\}^{poly(\lambda)}$, it holds that
		
		$$\Pr\left[(x;w)\in R; \langle\P(\pk,w),\A(\sigma) \rangle=\accept: (\pk,\vk)\leftarrow\mathcal{G}(1^\lambda); (x,w,\sigma)\leftarrow\A(z,\pk,\vk) \right] = $$
		$$\Pr\left[(x;w)\in R; \langle\S(\mathsf{trap}, z, \pk),\A(\sigma) \rangle=\accept:(\pk,\vk,\mathsf{trap})\leftarrow\S(1^\lambda); (x,w,\sigma)\leftarrow\A(z,\pk,\vk)\right]$$
		
		where $=$ means perfect zero knowledge. 
		
	\end{itemize}
	We say that $(\mathcal{G},\P,\V)$ is a \textbf{succinct} argument system if the
	running time of $\V$ and the total communication between $\P$ and $\V$ (proof size) are $\mathsf{poly}(\lambda,|x|,\log|w|)$.
\end{definition}

\input{CMT}
\input{zkvpd}
